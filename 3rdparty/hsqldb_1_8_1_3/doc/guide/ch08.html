<html><head><META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"><title>Chapter&nbsp;8.&nbsp;SqlTool</title><link href="guide.css" rel="stylesheet" type="text/css"><meta content="DocBook XSL Stylesheets V1.65.1" name="generator"><meta name="keywords" content="SqlTool, HSQLDB, SQL, JDBC"><meta name="keywords" content="Hsqldb, Hypersonic, Database, JDBC, Java"><link rel="home" href="index.html" title="Hsqldb User Guide"><link rel="up" href="index.html" title="Hsqldb User Guide"><link rel="previous" href="ch07.html" title="Chapter&nbsp;7.&nbsp;TLS"><link rel="next" href="ch09.html" title="Chapter&nbsp;9.&nbsp;SQL Syntax"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="navheader"><table summary="Navigation header" width="100%"><tr><th align="center" colspan="3">Chapter&nbsp;8.&nbsp;SqlTool</th></tr><tr><td align="left" width="20%"><a accesskey="p" href="ch07.html"><img src="navicons/prev.gif" alt="Prev"></a>&nbsp;</td><th align="center" width="60%">&nbsp;</th><td align="right" width="20%">&nbsp;<a accesskey="n" href="ch09.html"><img src="navicons/next.gif" alt="Next"></a></td></tr></table><hr></div><div class="chapter" lang="en"><div class="titlepage"><div><div><h2 class="title"><a name="sqltool-chapter"></a>Chapter&nbsp;8.&nbsp;SqlTool</h2></div><div><h3 class="subtitle"><i>SqlTool Manual</i></h3></div><div><div class="authorgroup"><div class="author"><h3 class="author"><span class="firstname">Blaine</span> <span class="surname">Simpson</span></h3><div class="affiliation"><span class="orgname">HSQLDB Development Group<br></span></div><tt class="email">&lt;<a href="mailto:blaine.simpson@admc.com">blaine.simpson@admc.com</a>&gt;</tt></div></div></div><div><p class="pubdate">$Date: 2007-08-08 09:03:49 -0400 (Wed, 08 Aug 2007) $</p></div></div><div></div></div><div class="toc"><p><b>Table of Contents</b></p><dl><dt><span class="section"><a href="ch08.html#N1122F">Purpose, Coverage, Changes in Behavior</a></span></dt><dd><dl><dt><span class="section"><a href="ch08.html#N1125C">Platforms and SqlTool versions covered</a></span></dt><dt><span class="section"><a href="ch08.html#N11277">Functional Changes</a></span></dt></dl></dd><dt><span class="section"><a href="ch08.html#baremin-section">The Bare Minimum</a></span></dt><dd><dl><dt><span class="section"><a href="ch08.html#N11347">Non-displayable Types</a></span></dt><dt><span class="section"><a href="ch08.html#N1136C">Desktop shortcuts</a></span></dt><dt><span class="section"><a href="ch08.html#N113EA">Loading sample data</a></span></dt></dl></dd><dt><span class="section"><a href="ch08.html#auth-section">RC File Authentication Setup</a></span></dt><dt><span class="section"><a href="ch08.html#ilauth-section">Using Inline RC Authentication</a></span></dt><dt><span class="section"><a href="ch08.html#N114EF">
            Using the current version of SqlTool with an older HSQLDB
            distribution.
        </a></span></dt><dt><span class="section"><a href="ch08.html#int-section">Interactive Usage</a></span></dt><dd><dl><dt><span class="section"><a href="ch08.html#N11542">Command Types</a></span></dt></dl></dd><dt><span class="section"><a href="ch08.html#N1155D">Command Types</a></span></dt><dt><span class="section"><a href="ch08.html#N115AE">Special Commands</a></span></dt><dt><span class="section"><a href="ch08.html#N11678">Edit Buffer / History Commands</a></span></dt><dt><span class="section"><a href="ch08.html#interactive_pl_commands-section">PL Commands</a></span></dt><dd><dl><dt><span class="section"><a href="ch08.html#N11792">? Variable</a></span></dt><dt><span class="section"><a href="ch08.html#binary_files-section">
                Storing and retrieving binary files</a></span></dt><dt><span class="section"><a href="ch08.html#N117E8">Command History</a></span></dt><dt><span class="section"><a href="ch08.html#N117F7">Shell scripting and command-line piping</a></span></dt><dt><span class="section"><a href="ch08.html#N11800">Emulating Non-Interactive mode</a></span></dt></dl></dd><dt><span class="section"><a href="ch08.html#nonint-section">Non-Interactive</a></span></dt><dd><dl><dt><span class="section"><a href="ch08.html#sqlswitch-section">Giving SQL on the Command Line</a></span></dt><dt><span class="section"><a href="ch08.html#N11853">SQL Files</a></span></dt><dt><span class="section"><a href="ch08.html#scripting-section">Piping and shell scripting</a></span></dt><dt><span class="section"><a href="ch08.html#N118CE">Optimally Compatible SQL Files</a></span></dt><dt><span class="section"><a href="ch08.html#N118E1">Comments</a></span></dt><dt><span class="section"><a href="ch08.html#N11904">Special Commands and Edit Buffer Commands in SQL Files</a></span></dt><dt><span class="section"><a href="ch08.html#N11972">Automation</a></span></dt><dt><span class="section"><a href="ch08.html#N1197D">Getting Interactive Functionality with SQL Files</a></span></dt><dt><span class="section"><a href="ch08.html#charencoding-section">
                Character Encoding</a></span></dt></dl></dd><dt><span class="section"><a href="ch08.html#report-section">Generating Text or HTML Reports</a></span></dt><dt><span class="section"><a href="ch08.html#pl-section">SqlTool Procedural Language</a></span></dt><dd><dl><dt><span class="section"><a href="ch08.html#N11A15">Variables</a></span></dt><dt><span class="section"><a href="ch08.html#pl_alias-section">PL Aliases</a></span></dt><dt><span class="section"><a href="ch08.html#N11A97">Logical Expressions</a></span></dt><dt><span class="section"><a href="ch08.html#N11B10">Flow Control</a></span></dt></dl></dd><dt><span class="section"><a href="ch08.html#chunk-section">Chunking</a></span></dt><dd><dl><dt><span class="section"><a href="ch08.html#N11B71">Why?</a></span></dt><dt><span class="section"><a href="ch08.html#N11B78">How?</a></span></dt></dl></dd><dt><span class="section"><a href="ch08.html#raw-section">Raw Mode</a></span></dt><dt><span class="section"><a href="ch08.html#N11BA2">PL/SQL</a></span></dt><dt><span class="section"><a href="ch08.html#altjar-section">Using hsqltool.jar and hsqldbutil.jar</a></span></dt><dt><span class="section"><a href="ch08.html#N11C3F">Delimiter-Separated-Value Imports and Exports</a></span></dt><dd><dl><dt><span class="section"><a href="ch08.html#N11C5F">Simple DSV exports and imports using default settings</a></span></dt><dt><span class="section"><a href="ch08.html#N11CA4">Specifying queries and options</a></span></dt></dl></dd><dt><span class="section"><a href="ch08.html#N11D26">Unit Testing SqlTool</a></span></dt></dl></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="N1122F"></a>Purpose, Coverage, Changes in Behavior</h2></div><div><h2 class="title" style="clear: both"><a name="N1122F"></a>Purpose, Coverage, Changes in Behavior</h2></div></div><div></div></div><p>
            This document explains how to use SqlTool, the main purpose of
            which is to read your SQL text file or stdin, and execute the SQL 
            commands therein against a JDBC database.
            There are also a great number of features to facilitate both
            interactive use and automation.
            The following paragraphs explain in a general way why SqlTool is
            better than any existing tool for text-mode interactive SQL work, 
            and for automated SQL tasks.
            Two important benefits which SqlTool shares with other pure Java 
            JDBC tools is that users can use a consistent interface and 
            syntax to interact with a huge variety of databases-- any
            database which supports JDBC; plus the tool itself runs on any
            Java platform.
            Instead of using <tt class="filename">isql</tt> for Sybase, 
            <tt class="filename">psql</tt> for Postgresql,
            <tt class="filename">Sql*plus</tt> for Oracle, etc., you can 
            use SqlTool for all of them.
            As far as I know, SqlTool is the only production-ready, pure
            Java, command-line, generic JDBC client.
            Several databases come with a command-line client with limited
            JDBC abilities (usually designed for use with their specific
            database).
        </p><p>
          SqlTool is purposefully not a Gui tool like Toad or DatabaseManager.
          There are many use cases where a Gui SQL tool would be better.
          Where automation is involved in any way, you really need a text
          client to at least test things properly and usually to prototype
          and try things out.
          A command-line tool is really better for executing SQL scripts,
          any form of automation, direct-to-file fetching, and remote client 
          usage.
          To clarify this last, if you have to do your SQL client work on a 
          work server on the other side of a VPN connection, you will quickly
          appreciate the speed difference between text data transmission
          and graphical data transmission, even if using VNC or Remote Console.
          Another case would be where you are doing some repetitive or
          very structured work where variables or language features would
          be useful.
          Gui proponents may disagree with me, but scripting (of any sort)
          is more efficient than repetitive copy &amp; pasting with a Gui
          editor.
          SqlTool starts up very quickly, and it takes up a tiny fraction of
          the RAM required to run a comparably complex Gui like Toad.
        </p><p>
          SqlTool is superior for interactive use because over many years it
          has evolved lots of features proven to be efficient for day-to-day 
          use.
          Three concise help commands (\?, :?, and *?) list all available
          commands of the corresponding type.
          SqlTool doesn't support up-arrow or other OOB escapes (due to basic 
          Java I/O limitations), but it more than makes up for this limitation 
          with aliases, user variables, command-line history and recall, and
          command-line editing with extended Perl/Java regular expressions.
          The \d commands deliver JDBC metadata information as consistently as
          possible (in several cases, database-specific work-arounds are used
          to obtain the underlying data even though the database doesn't 
          provide metadata according to the JDBC specs).
          Unlike server-side language features, the same feature set works 
          for any database server.
          Database access details may be supplied on the command line, but 
          day-to-day users will want to centralize JDBC connection details
          into a single, protected RC file.
          You can put connection details (username, password, URL, and other
          optional settings) for scores of target databases into your RC file,
          then connect to any of them whenever you want by just giving 
          SqlTool the ID ("urlid") for that database.
          When you Execute SqlTool interactively, it behaves by default 
          exactly as you would want it to.
          If errors occur, you are given specific error messages and you
          can decide whether to roll back your session.
          You can easily change this behavior to auto-commit,
          exit-upon-error, etc., for the current session or for all
          interactive invocations.
          You can import or export delimiter-separated-value files.
        </p><p>
          When you Execute SqlTool with a SQL script, it behaves by default 
          exactly as you would want it to.
          If any error is encountered, the connection will be rolled back,
          then SqlTool will exit with an error exit value.
          If you wish, you can detect and handle error (or other) conditions
          yourself.
          For scripts expected to produce errors (like many scripts provided
          by database vendors), you can have SqlTool continue-upon-error.
          For SQL script-writers, you will have access to portable scripting
          features which you've had to live without until now.
          You can use variables set on the command line or in your script.
          You can handle specific errors based on the output of SQL commands
          or of your variables.
          You can chain SQL scripts, invoke external programs, dump data
          to files, use prepared statements, 
          Finally, you have a procedural language with <tt class="literal">if</tt>,
          <tt class="literal">foreach</tt>, <tt class="literal">while</tt>,
          <tt class="literal">continue</tt>, and <tt class="literal">break</tt> statements.
        </p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="N1125C"></a>Platforms and SqlTool versions covered</h3></div></div><div></div></div><p>
            SqlTool runs on any Java 1.4 or later platform.
            I haven't run it with a non-Sun JVM in years (like Blackdown,
            IBM, JRockit, etc.), but I've had no reports of problems with
            them, and SqlTool uses none of the Sun-proprietary classes
            directly.
            Some of the examples below use quoting which works exactly
            as-is for any Bourne-compatible UNIX shell.
            (Only line-continuation would need to be changed for C-compatible
            UNIX shells).
            I have not yet tested these commands on Windows, and I doubt
            whether the quoting will work just like this (though it is
            possible).
            SqlTool is still a very useful tool even if you have no quoting
            capability at all.
        </p><p>
            If you are using SqlTool from a HSQLDB distribution before
            version 1.8.0.8 final, you should use the documentation with that
            distribution, because this manual documents many new features,
            several significant changes to interactive-only commands, and
            a few changes effecting backwards-compatibility (see next
            section about that).
            This document is now updated for the current versions of SqlTool
            and SqlFile at the time I am writing this (versions 333 and
            354 correspondingly, SqlFile is the class which does most of the
            work for SqlTool).
            Therefore, if you are using a version of SqlTool or SqlFile that
            is more than a couple revisions greater, you should find a newer
            version of this document.
            (The imprecision is due to content-independent revision increments
            at build time, and the likelihood of one or two 
            behavior-independent bug fixes after public releases).
            The startup banner will report both versions when you run SqlTool
            interactively.
            (Dotted version numbers of SqlTool and SqlFile are older than 
            333 and 354).
        </p><p>
            This guide covers SqlTool bundled with series 1.8 and 1.9 of
            HSQLDB.
            <sup>[<a href="#ftn.samplelocFn" name="samplelocFn">1</a>]</sup>
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="N11277"></a>Functional Changes</h3></div></div><div></div></div><p>This section lists changes to SqlTool since the last
              major release of HSQLDB which may effect the portability
              of SQL scripts.
              For this revision of this document, this list consists of
              script-impacting changes made to SqlTool
              <span class="emphasis"><em>after</em></span> the final 1.8.0.0 HSQLDB release.
              I'm specifically not listing changes to interactive-only
              commands (":" commands, with one legacy exception which is
              listed below), since these commands can't be used in SQL scripts;
              and I'm specifically not listing backwards-compatible feature
              additions and enhancements.
              The reason for limiting the change list to only portability-
              impacting changes is that a list of all enhancements since 
              just 1.8.0.0 would be pages long.
            </p><div class="itemizedlist"><ul type="disc"><li>
                  SqlTool now consistently outputs \r\n line breaks when 
                  on \r\n-linebreak platforms, like Windows.
                  This includes output written to stdout, \w files,
                  and \o files.
                </li><li>
                  Time type values are always output with the date as
                  well as the time.
                  This was required in order to produce consistent output
                  for the wildly varying formats provided by different
                  database vendors.
                </li><li>
                  DSV input now takes JDBC Timestamp format with date and
                  optionally time of day.
                </li><li>
                  The command ":;" is now strictly an interactive command.
                  If you want to repeat a command in an SQL scripts, just
                  repeat the exact text of the command.
                  Non-interactive use now has no dependency on command history.
                </li><li>
                  The command ":w" has replace the command \w.
                  Unlike writing "output" to a file with \w, :w is used to
                  write SQL "commands", and this is an interactive feature.
                </li><li>
                  Shell scripts using raw mode (e.g. PL/SQL scripts) must
                  terminate the raw code with a line containing ".;", which
                  will also send the code to the database for execution.
                  (The old "." command has been changed to ":." to make it
                  very clear that the command is now an interactive command).
                </li><li>
                  The --sql argument will never automatically append a 
                  semicolon to the text you provide.
                  If you want to execute a command ending with a semi--
                  then type a semi.
                </li></ul></div><p>
                Although it doesn't effect scripts, I will mention a
                significant recent change to interactive commands.
                Special and PL commands are not stored to the edit buffer
                and to command history, so they can be recalled and edited
                just like SQL commands.  Now, only edit/history : commands
                are not stored to the buffer and history.
            </p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="baremin-section"></a>The Bare Minimum You Need to Know to Run SqlTool</h2></div></div><div></div></div><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Warning</h3><p>
            If you are using an Oracle database server, it will commit your
            current transaction if you cleanly disconnect, regardless of
            whether you have set auto-commit or not.
            This will occur if you exit SqlTool (or any other client) in
            the normal way (as opposed to killing the process or using
            Ctrl-C, etc.).
            This is mentioned in this section only for brevity, so I don't
            need to mention it in the main text in the many places where
            auto-commit is discussed.
            This behavior has nothing to do with SqlTool.
            It is a quirk of Oracle.
        </p></div><p>
            If you want to use SqlTool, then you either have an SQL text file, 
            or you want to interactively type in SQL commands.
            If neither case applies to you, then you are looking at the wrong 
            program.
        </p><div class="procedure"><p class="title"><b>Procedure&nbsp;8.1.&nbsp;To run SqlTool...</b></p><ol type="1"><li><p>
                    Copy the file <tt class="filename">sqltool.rc</tt> from the
                    directory <tt class="filename">sample</tt>
                    <sup>[<a href="#ftn.samplelocFn">1</a>]</sup>
                    of your HSQLDB distribution to your home directory and
                    secure access to it if your computer is accessible
                    to anybody else (most likely from the network).
                    This file will work as-is for a Memory Only database
                    instance; or if your target is a HSQLDB Server 
                    running on your local computer with default settings
                    and the password for the "sa" account is blank
                    (the sa password is blank when new HSQLDB database 
                    instances are created).
                    Edit the file if you need to change the target Server URL, 
                    username, password, character set, JDBC driver, or TLS 
                    trust store as documented in the 
                    <a href="ch08.html#auth-section" title="RC File Authentication Setup">RC File Authentication Setup</a>
                    section.
                    (You could, alternatively, use the
                    <tt class="literal">--inlineRc</tt> command-line switch to 
                    specify your connection parameters as documented in the 
                    <a href="ch08.html#ilauth-section" title="Using Inline RC Authentication">Using Inline RC Authentication</a>
                    section).
                </p></li><li><p>
                    Find out where your hsqldb.jar file resides.
                    It typically resides at
<span class="bold"><b>HSQLDB_HOME</b></span><tt class="filename">/lib/hsqldb.jar</tt>
                    where <span class="bold"><b>HSQLDB_HOME</b></span> is the
                    base directory of your HSQLDB software installation.
                    For this reason, I'm going to use 
                    "$HSQLDB_HOME/lib/hsqldb.jar" as the path to
                    <tt class="filename">hsqldb.jar</tt> for my examples, but 
                    understand that you need to use the actual path to your
                    own <tt class="filename">hsqldb.jar</tt> file.
                </p></li><li><p>
                    Run 
                <div class="informalexample"><pre class="screen">
    java -jar $HSQLDB_HOME/lib/hsqldb.jar --help</pre></div>
                    to see what command-line arguments are available.
                    Note that you don't need to worry about setting the 
                    CLASSPATH when you use the <tt class="literal">-jar</tt> switch
                    to <tt class="filename">java</tt>.
                    Assuming that you set up your SqlTool RC file 
                    at the default location and you want to use the HSQLDB 
                    JDBC driver, you will want to run something like
                <div class="informalexample"><pre class="screen">
    java -jar $HSQLDB_HOME/lib/hsqldb.jar mem</pre></div>
                    for interactive use, or
                <div class="informalexample"><pre class="screen">
    java -jar $HSQLDB_HOME/lib/hsqldb.jar --sql 'SQL statement;' mem</pre></div>
                    or
                    <div class="informalexample"><pre class="screen">
    java -jar $HSQLDB_HOME/lib/hsqldb.jar mem filepath1.sql...</pre></div>
                    where <tt class="literal">mem</tt> is an
                    <span class="emphasis"><em>urlid</em></span>,
                    and the following arguments are paths to text SQL files.
                    For the filepaths, you can use whatever wildcards your 
                    operating system shell supports.
                    </p><p>
                    The <span class="emphasis"><em>urlid</em></span> <tt class="literal">mem
                    </tt>in these commands is a key 
                    into your RC file, as explained in the 
                    <a href="ch08.html#auth-section" title="RC File Authentication Setup">RC File Authentication Setup</a> section.
                    Since this is a Memory Only database, you can use SqlTool
                    with this urlid immediately with no database setup 
                    whatsoever (however, you can't persist any changes that 
                    you make to this database).
                    The sample sqltool.rc file also defines the urlid
                    "localhost-sa" for a local HSQLDB Server.
                    At the end of this section, I explain how you can load
                    some sample data to play with, if you want to.
                </p></li></ol></div><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Important</h3><p>
            SqlTool does not <span class="emphasis"><em>commit</em></span> SQL changes by default.
            This leaves it to the user's disgression whether to commit or
            rollback their modifications.
            Remember to either run \= to commit before quitting SqlTool
            (most databases also support the SQL command
            <tt class="literal">commit;</tt>,
            or use the <tt class="literal">--autoCommit</tt> command-line switch.
        </p></div><p>
            If you put a file named <tt class="filename">auto.sql</tt> into your
            home directory, this file will be executed automatically every
            time that you run SqlTool interactively and without the
            <tt class="literal">--noAutoFile</tt> switch.
        </p><p>
            To use a JDBC Driver other than the HSQLDB driver, you can't use
            the <tt class="literal">-jar</tt> switch because you need to modify the
            classpath.
            You must add the hsqldb.jar file and your JDBC driver classes to
            your classpath,
            and you must tell SqlTool what the JDBC driver class name is.
            The latter can be accomplished by either using the "--driver" 
            switch, or setting "driver" in your config file.
            The <a href="ch08.html#auth-section" title="RC File Authentication Setup">RC File Authentication Setup</a> section.
            explains the second method.  Here's an example of the first method
            (after you have set the classpath appropriately).
        <div class="informalexample"><pre class="screen">
java org.hsqldb.util.SqlTool --driver oracle.jdbc.OracleDriver urlid</pre></div></p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Tip</h3><p>
            If the tables of query output on your screen are all messy 
            because of lines wrapping, the best and easiest solution
            is usually to resize your terminal emulator window to make it
            wider.
            (With some terms you click &amp; drag the frame edges to resize,
            with others you use a menu system where you can enter the number
            of columns).
        </p></div><p>
            If you are using SqlTool to connect to a HSQLDB network server
            or any non-HSQLDB database, you may prefer to use the jar file
            <tt class="filename">hsqltool.jar</tt> or
            <tt class="filename">hsqldbutil.jar</tt> instead of
            <tt class="filename">hsqldb.jar</tt>.
            These alternative jar files contain all of SqlTool without stuff
            you don't need, but you will have to follow a simple procedure to
            generate these jars.
            See the <a href="ch08.html#altjar-section" title="Using hsqltool.jar and hsqldbutil.jar">Using hsqltool.jar and hsqldbutil.jar</a>
            section.
        </p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="N11347"></a>Non-displayable Types</h3></div></div><div></div></div><p>
            There are many SQL types which SqlTool (being a text-based
            program) can't display properly.
            This includes the SQL types <tt class="literal">BLOB</tt>,
            <tt class="literal">JAVA_OBJECT</tt>, <tt class="literal">STRUCT</tt>,
            and <tt class="literal">OTHER</tt>.
            When you run a query that returns any of these, SqlTool will
            save the very first such value obtained to the binary buffer
            and will not display any output from this query.
            You can then save the binary value to a file, as explained in the
          <a href="ch08.html#binary_files-section" title="
                Storing and retrieving binary files">
                Storing and retrieving binary files</a>
            section.
            </p><p>
            There are other types, such as <tt class="literal">BINARY</tt>, which
            JDBC can make displayable (by using ResultSet.getString()), but 
            which you may very well want to retrieve in raw binary format.
            You can use the \b command to retrieve any-column-type-at-all
            in raw binary format (so you can later store the value to a
            binary file).
            </p><p>
            Another restriction which all text-based database clients have
            is the practical inability for the user to type in binary data 
            such as photos, audio streams, and serialized Java objects.
            You can use SqlTool to load any binary object into a database
            by telling SqlTool to get the insert/update datum from a file.
            This is also explained in the
          <a href="ch08.html#binary_files-section" title="
                Storing and retrieving binary files">
                Storing and retrieving binary files</a>
            section.
            </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="N1136C"></a>Desktop shortcuts</h3></div></div><div></div></div><p>
                Desktop shortcuts and quick launch icons are useful, especially 
                if you often run SqlTool with the same set of arguments.
                It's really easy to set up several of them-- one for each 
                way that you invoke SqlTool (i.e., each one would start
                SqlTool with all the arguments for one of your typical startup
                needs).
                One typical setup is to have one shortcut for each database 
                account which you normally use (use a different
                <tt class="literal">urlid</tt> argument in each shortcut's
                <span class="guilabel">Target</span> specification.
            </p><p>
                Desktop icon setup varies depending on your Desktop manager,
                of course.
                I'll explain how to set up a SqlTool startup icon in Windows
                XP.
                Linux and Mac users should be able to take it from there, since
                it's easier with the common Linux and Mac desktops.
            </p><div class="procedure"><p class="title"><b>Procedure&nbsp;8.2.&nbsp;Creating a Desktop Shortcut for SqlTool</b></p><ol type="1"><li><p>
                    Right click in the main Windows background.
                </p></li><li><p>
                    <span class="guimenuitem">New</span>
                </p></li><li><p>
                    <span class="guimenuitem">Shortcut</span>
                </p></li><li><p>
                    <span class="guibutton">Browse</span>
                </p></li><li><p>
                    Navigate to where your good JRE lives.  For recent Sun
                    JRE's, it installs to 
                    <tt class="filename">C:\Program Files\Java\*\bin</tt>
                    by default (the * will be a JDK or JRE name and version 
                    number).
                </p></li><li><p>
                    Select <tt class="filename">java.exe</tt>.
                </p></li><li><p>
                    <span class="guibutton">OK</span>
                </p></li><li><p>
                    <span class="guimenuitem">Next</span>
                </p></li><li><p>
                    Enter any name
                </p></li><li><p>
                    <span class="guimenuitem">Finish</span>
                </p></li><li><p>
                    Right click the new icon.
                </p></li><li><p>
                    <span class="guimenuitem">Properties</span>
                </p></li><li><p>
                    Edit the <span class="guilabel">Target</span> field.
                </p></li><li><p>
                    Leave the path to java.exe exactly as it is, including the 
                    quotes, but append to what is there.
                    Beginning with a space, enter the command-line that you
                    want run.
                </p></li><li><p>
                    <span class="guibutton">Change Icon...</span> to a pretty icon.
                </p></li><li><p>
                    If you want a quick-launch icon instead of (or in addition 
                    to) a desktop shortcut icon, click and drag it to your 
                    quick launch bar.  (You may or may not need to edit the
                    Windows Toolbar properties to let you add new items).
                </p></li></ol></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="N113EA"></a>Loading sample data</h3></div></div><div></div></div><p>
                If you want some sample database objects and data to play 
                with, execute the <tt class="filename">sampledata.sql</tt> SQL 
                file.
                <tt class="filename">sampledata.sql</tt> resides in the
                <tt class="filename">sample</tt> directory of your
                HSQLDB distribution <sup>[<a href="#ftn.samplelocFn">1</a>]</sup>.
                To separate the sample data from your regular data, you can
                put it into its own schema by running this before you import:
            <div class="informalexample"><pre class="programlisting">
    CREATE SCHEMA sampledata AUTHORIZATION dba;
    SET SCHEMA sampledata;</pre></div>
                Run it like this from an SqlTool session
    <pre class="programlisting">\i HSQLDB_HOME/sample/sampledata.sql</pre>
                where <span class="bold"><b>HSQLDB_HOME</b></span> is the
                base directory of your HSQLDB software installation
                <sup>[<a href="#ftn.samplelocFn">1</a>]</sup>.
            </p><p>
                For memory-only databases, you'll need to run this every 
                time that you run SqlTool.
                For other (persistent) databases, the data will reside in 
                your database until you drop the tables.
            </p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="auth-section"></a>RC File Authentication Setup</h2></div></div><div></div></div><p>
            RC file authentication setup is accomplished by creating a text
            RC configuration file.
            In this section, when I say <span class="emphasis"><em>configuration</em></span>
            or <span class="emphasis"><em>config</em></span> file, I mean an RC configuration 
            file.
            RC files can be used by any JDBC client program that uses the
            org.hsqldb.util.RCData class-- this includes
            SqlTool, DatabaseManager, DatabaseManagerSwing.
            You can use it for your own JDBC client programs too.
        </p><p>
            The following sample RC file resides at 
            <tt class="filename">sample/sqltool.rc</tt> in your HSQLDB distribution
            <sup>[<a href="#ftn.samplelocFn">1</a>]</sup>.
        </p><div class="example"><a name="N11426"></a><p class="title"><b>Example&nbsp;8.1.&nbsp;Sample RC File</b></p><pre class="programlisting"># $Id: sqltool.rc 338 2007-07-13 03:15:23Z unsaved $

# This is a sample RC configuration file used by SqlTool, DatabaseManager,
# and any other program that uses the org.hsqldb.util.RCData class.

# You can run SqlTool right now by copying this file to your home directory
# and running
#    java -jar /path/to/hsqldb.jar mem
# This will access the first urlid definition below in order to use a 
# personal Memory-Only database.
# "url" values may, of course, contain JDBC connection properties, delimited
# with semicolons.

# If you have the least concerns about security, then secure access to
# your RC file.
# See the documentation for SqlTool for various ways to use this file.

# A personal Memory-Only (non-persistent) database.
urlid mem
url jdbc:hsqldb:mem:memdbid
username sa
password

# A personal, local, persistent database.
urlid personal
url jdbc:hsqldb:file:${user.home}/db/personal;shutdown=true
username sa
password
# When connecting directly to a file database like this, you should 
# use the shutdown connection property like this to shut down the DB
# properly when you exit the JVM.

# This is for a hsqldb Server running with default settings on your local
# computer (and for which you have not changed the password for "sa").
urlid localhost-sa
url jdbc:hsqldb:hsql://localhost
username sa
password



# Template for a urlid for an Oracle database.
# You will need to put the oracle.jdbc.OracleDriver class into your 
# classpath.
# In the great majority of cases, you want to use the file classes12.zip
# (which you can get from the directory $ORACLE_HOME/jdbc/lib of any
# Oracle installation compatible with your server).
# Since you need to add to the classpath, you can't invoke SqlTool with
# the jar switch, like "java -jar .../hsqldb.jar..." or 
# "java -jar .../hsqlsqltool.jar...".
# Put both the HSQLDB jar and classes12.zip in your classpath (and export!)
# and run something like "java org.hsqldb.util.SqlTool...".

#urlid cardiff2
#url jdbc:oracle:thin:@aegir.admc.com:1522:TRAFFIC_SID
#username blaine
#password secretpassword
#driver oracle.jdbc.OracleDriver



# Template for a TLS-encrypted HSQLDB Server.
# Remember that the hostname in hsqls (and https) JDBC URLs must match the
# CN of the server certificate (the port and instance alias that follows 
# are not part of the certificate at all).
# You only need to set "truststore" if the server cert is not approved by
# your system default truststore (which a commercial certificate probably
# would be).

#urlid tls
#url jdbc:hsqldb:hsqls://db.admc.com:9001/lm2
#username blaine
#password asecret
#truststore /home/blaine/ca/db/db-trust.store


# Template for a Postgresql database
#urlid blainedb
#url jdbc:postgresql://idun.africawork.org/blainedb
#username blaine
#password losung1
#driver org.postgresql.Driver

# Template for a MySQL database.  MySQL has poor JDBC support.
#urlid mysql-testdb
#url jdbc:mysql://hostname:3306/dbname
#username root
#username blaine
#password hiddenpwd
#driver com.mysql.jdbc.Driver

# Note that "databases" in SQL Server and Sybase are traditionally used for
# the same purpose as "schemas" with more SQL-compliant databases.

# Template for a Microsoft SQL Server database
#urlid msprojsvr
#url jdbc:microsoft:sqlserver://hostname;DatabaseName=DbName;SelectMethod=Cursor
# The SelectMethod setting is required to do more than one thing on a JDBC
# session (I guess Microsoft thought nobody would really use Java for 
# anything other than a "hello world" program).
# This is for Microsoft's SQL Server 2000 driver (requires mssqlserver.jar
# and msutil.jar).
#driver com.microsoft.jdbc.sqlserver.SQLServerDriver
#username myuser
#password hiddenpwd

# Template for a Sybase database
#urlid sybase
#url jdbc:sybase:Tds:hostname:4100/dbname
#username blaine
#password hiddenpwd
# This is for the jConnect driver (requires jconn3.jar).
#driver com.sybase.jdbc3.jdbc.SybDriver

# Template for Embedded Derby / Java DB.
#urlid derby1
#url jdbc:derby:path/to/derby/directory;create=true
#username ${user.name}
#password any_noauthbydefault
#driver org.apache.derby.jdbc.EmbeddedDriver
# The embedded Derby driver requires derby.jar.
# There'a also the org.apache.derby.jdbc.ClientDriver driver with URL
# like jdbc:derby://&lt;server&gt;[:&lt;port&gt;]/databaseName, which requires
# derbyclient.jar.
# You can use \= to commit, since the Derby team decided (why???)
# not to implement the SQL standard statement "commit"!!
# Note that SqlTool can not shut down an embedded Derby database properly,
# since that requires an additional SQL connection just for that purpose.
# However, I've never lost data by not shutting it down properly.
# Other than not supporting this quirk of Derby, SqlTool is miles ahead of ij.
</pre></div><p>
            You can put this file anywhere you want to, and specify the 
            location to SqlTool/DatabaseManager/DatabaseManagerSwing by
            using the <tt class="literal">--rcfile</tt> argument.
            If there is no reason to not use the default location (and there 
            are situations where you would not want to), then use the default
            location and you won't have to give <tt class="literal">--rcfile</tt>
            arguments to SqlTool/DatabaseManager/DatabaseManagerSwing.
            The default location is <tt class="filename">sqltool.rc</tt> or
            <tt class="filename">dbmanager.rc</tt> in your home directory
            (corresponding to the program using it).
            If you have any doubt about where your home directory is, just 
            run SqlTool with a phony urlid and it will tell you where it 
            expects the configuration file to be.
        <div class="informalexample"><pre class="screen">
    java -jar $HSQLDB_HOME/lib/hsqldb.jar x</pre></div></p><p>
            The config file consists of stanza(s) like this:
        <div class="informalexample"><pre class="screen">
    urlid web
    url jdbc:hsqldb:hsql://localhost
    username web
    password webspassword</pre></div></p><p>
            These four settings are required for every urlid.
            (There are optional settings also, which are described a couple 
            paragraphs down).
            The URL may contain JDBC connection properties.
            You can have as many blank lines and comments like
        <div class="informalexample"><pre class="screen">
    # This comment</pre></div>
        </p><p>
            in the file as you like.
            The whole point is that the <span class="emphasis"><em>urlid</em></span> that you 
            give in your SqlTool/DatabaseManager command must match a 
            <span class="emphasis"><em>urlid </em></span> in your configuration file.
        </p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Important</h3><p>
            Use whatever facilities are at  your disposal to protect your 
            configuration file.
        </p></div><p>
            It should be readable, both locally and remotely, only to users 
            who run programs that need it.
            On UNIX, this is easily accomplished by using <tt class="literal">chmod/chown
            </tt> commands and making sure that it is protected from 
            anonymous remote access (like via NFS, FTP or Samba).
        </p><p>
            You can also put the following optional settings into a urlid 
            stanza.  The setting will, of course, only apply to that urlid.
        </p><div class="variablelist"><dl><dt><span class="term">charset</span></dt><dd>
                This is used by the SqlTool program, but not by the
                DatabaseManager programs.
                See the <a href="ch08.html#charencoding-section" title="
                Character Encoding">
                Character Encoding</a> section of the
                <a href="ch08.html#nonint-section" title="Non-Interactive">Non-Interactive</a>
                section.
                You can, alternatively, set this for one SqlTool invocation 
                by setting the system property <span class="property">sqlfile.charset
                </span>.
                Defaults to <tt class="literal">US-ASCII</tt>.
            </dd><dt><span class="term">driver</span></dt><dd>
                Sets the JDBC driver class name.
                You can, alternatively, set this for one 
                SqlTool/DatabaseManager invocation by using the command 
                line switch <span class="emphasis"><em>--driver</em></span>.
                Defaults to <span class="emphasis"><em>org.hsqldb.jdbcDriver</em></span>.
            </dd><dt><span class="term">truststore</span></dt><dd>
                TLS trust keystore store file path as documented in the
                <a href="ch07.html" title="Chapter&nbsp;7.&nbsp;TLS">TLS</a> chapter.
                You usually only need to set this if the server is using a
                non-publicly-certified certificate (like a self-signed 
                self-ca'd cert).
            </dd></dl></div><p>
            Property and SqlTool command-line switches override settings made 
            in the configuration file.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="ilauth-section"></a>Using Inline RC Authentication</h2></div></div><div></div></div><p>
            Inline RC authentication setup is accomplished by using the
            <tt class="literal">--inlineRc</tt> command-line switch on SqlTool.
            The <tt class="literal">--inlineRc</tt> command-line switch takes 
            a comma-separated list of key/value elements.
            The <tt class="literal">url</tt> and <tt class="literal">user</tt> elements
            are required.  The rest are optional.
        </p><div class="variablelist"><dl><dt><span class="term"><tt class="literal">url</tt></span></dt><dd>
                The JDBC URL of the database you wish to connect to.
            </dd><dt><span class="term"><tt class="literal">user</tt></span></dt><dd>
                The username to connect to the database as.
            </dd><dt><span class="term"><tt class="literal">charset</tt></span></dt><dd>
                Sets the character encoding. Defaults to <tt class="literal">US-ASCII</tt>.
            </dd><dt><span class="term"><tt class="literal">trust</tt></span></dt><dd>
                The TLS trust keystore file path as documented in the TLS chapter.
            </dd><dt><span class="term"><tt class="literal">password</tt></span></dt><dd>
                You may only use this element to set empty password, like
                <div class="informalexample"><pre class="screen">
                    password=</pre></div>.  For any other password value, omit the
                <tt class="literal">password</tt> element and you will be prompted
                for the value.
            </dd></dl></div><p>
            (Use the <tt class="literal">--driver</tt> switch instead of
            <tt class="literal">--inlineRc</tt> to specify a JDBC driver class).
            Here is an example of invoking SqlTool to connect to a standalone database.
            <div class="informalexample"><pre class="screen">
    java -jar $HSQLDB_HOME/lib/hsqldb.jar
         --inlineRc URL=jdbc:hsqldb:file:/home/dan/dandb,USER=dan</pre></div>
        </p><p>
            For security reasons, you cannot specify a non-empty password as 
            an argument. You
            will be prompted for a password as part of the login process.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="N114EF"></a>
            Using the current version of SqlTool with an older HSQLDB
            distribution.
        </h2></div></div><div></div></div><p>This procedure will allow users of a legacy version of
            HSQLDB to use all of the new features of SqlTool.
            You will also get the new versions of the DatabaseManagers!
            This procedure works for distros going back to 1.7.3.3 at least,
            probably much farther.
        </p><p>
            Follow the instructions in the
            See the <a href="ch08.html#altjar-section" title="Using hsqltool.jar and hsqldbutil.jar">Using hsqltool.jar and hsqldbutil.jar</a>
            section to build the jar file <tt class="filename">hsqldbutil.jar</tt>.
        </p><p>
            For now on, whenever you are going to run SqlTool, make sure
            that you have this <tt class="filename">hsqldbutil.jar</tt> as
            the first item in your CLASSPATH.
            You can't run SqlTool with the "-jar" switch (because the
            -jar switch doesn't permit setting your own class path).
        </p><p>
            Here's a UNIX example where somebody wants to use the new SqlTool
            with their older HSQLDB database, as well as with Postgresql
            and a local application.
            <div class="informalexample"><pre class="screen">
CLASSPATH=/path/to/hsqldbutil.jar:/home/bob/classes:/usr/local/lib/pg.jdbc3.jar
export CLASSPATH
java org.hsqldb.util.SqlTool urlid</pre></div>
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="int-section"></a>Interactive Usage</h2></div></div><div></div></div><p>
            Do read the
            <a href="ch08.html#baremin-section" title="The Bare Minimum You Need to Know to Run SqlTool">The Bare Minimum</a>
            section before you read this section.
        </p><p>
            You run SqlTool interactively by specifying no SQL filepaths on 
            the SqlTool command line.  Like this.
        <div class="informalexample"><pre class="screen">
    java -jar $HSQLDB_HOME/lib/hsqldb.jar urlid</pre></div></p><div class="procedure"><p class="title"><b>Procedure&nbsp;8.3.&nbsp;What happens when SqlTool is run interactively
                (using all default settings)
            </b></p><ol type="1"><li><p>
                SqlTool starts up and connects to the specified database,
                using your SqlTool configuration file
                (as explained in the
                <a href="ch08.html#auth-section" title="RC File Authentication Setup">RC File Authentication Setup</a> section).
            </p></li><li><p>
                SQL file <tt class="filename">auto.sql</tt> in your home directory 
                is executed (if there is one),
            </p></li><li><p>
                SqlTool displays a
                banner showing the SqlTool and SqlFile version numbers and 
                describes the different command types that you can give, as 
                well as commands to list all of the specific commands available 
                to you.
            </p></li></ol></div><p>
            You exit your session by using the "\q" special command or ending 
            input (like with Ctrl-D or Ctrl-Z).
        </p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Important</h3><p>
            Every command (regardless of type) and comment must begin at the
            beginning of a line (or immediately after a comment ends with
            "*/").
        </p><p>
            You can't nest commands or comments.
            You can only start new commands (and comments) after the preceding
            statement has been terminated.
            (Remember that if you're running SqlTool interactively, you 
            can terminate an SQL statement without executing it by entering a
            blank line).
        </p><p>
          (Special Commands, Edit Buffer Commands and PL Commands always 
          consist of just one line.
          Any of these commands or comments may be preceded by space 
          characters.)
        </p><p>
            These rules do not apply at all to
            <a href="ch08.html#raw-section" title="Raw Mode">Raw Mode</a>.
            Raw mode is for use by advanced users when they want to completely
            bypass SqlTool processing in order to enter a chunk of text for
            direct transmission to the database engine.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="N11542"></a>Command Types</h3></div></div><div></div></div><p>
            When you are typing into SqlTool, you are always typing part of
            the <span class="emphasis"><em>immediate command</em></span>.
            You execute the immediate command by hitting ENTER after a 
            semi-colon (for SQL commands) or by just hitting ENTER (after
            any other non-empty command-- see next section about this
            distinction).
            The interactive : commands can perform actions with or on the
            edit buffer.
            The <span class="emphasis"><em>edit buffer</em></span> usually contains a copy of
            the last command executed, and you can always view it with the :b
            command.
            If you never use any : commands, you can entirely ignore the
            edit buffer.
            If you want to repeat commands or edit previous commands, you
            will need to work with the edit buffer.
            The immediate command contains whatever (and exactly what) 
            you type.
            The command history and edit buffer may contain any type of
            command other than comments and : commands
            (i.e., : commands and comments are just not copied to the history 
            or to the edit buffer).
          </p><p>
            Hopefully an example will clarify the difference between the
            immediate command and the edit buffer.
            If you type in the edit buffer Substitution command
            "<tt class="literal">:s/tbl/table/</tt>", the :s command that you typed
            is the immediate command (and it will never be stored to the
            edit buffer or history, since it is a : command), but the purpose
            of the substitution command is to modify the contents of the
            edit buffer (perform a substitution on it)-- the goal being that
            after your substitutions you would execute the buffer with the
            "<tt class="literal">:;</tt>" command.
            The ":a" command is special in that when you hit ENTER to execute
            it, it copies the contents of the edit buffer to a new immediate
            command and leaves you in a state where you are
            <span class="emphasis"><em>appending</em></span> to that
            <span class="emphasis"><em>immediate</em></span> command (nearly) exactly as if
            you had just typed it in.
        </p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="N1155D"></a>Command Types</h2></div></div><div></div></div><div class="variablelist"><p class="title"><b>Command types</b></p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
                Above, we said that if you enter an SQL command, one
                SQL command corresponds to one SqlTool command.
                This is the most typical usage, however,
                you can actually put multiple SQL statements into one
                SQL command.
                One example would be
        <div class="informalexample"><pre class="screen">
    INSERT INTO t1 VALUES(0); SELECT * FROM t1;</pre></div>
                This is one SqlTool command containing two SQL statements.
                See the 
                <a href="ch08.html#chunk-section" title="Chunking">Chunking</a>
                section to see why you may want to <span class="emphasis"><em>chunk</em></span>
                SQL commands, how, and the implications.
            </p></div><dl><dt><span class="term">SQL Statement</span></dt><dd><p>
                Any command that you enter which does not begin with "\", ":", 
                or "* " is an SQL Statement.
                The command is not terminated when you hit ENTER, like most 
                OS shells.
                You terminate SQL Statements with either ";" at the end of a 
                line, or with a blank line.
                In the former case, the SQL Statement will be executed against 
                the SQL database and the command will go into the edit
                buffer and SQL command history for editing or viewing later on.
                In the former case, 
                <span class="emphasis"><em>execute against the SQL database</em></span> means
                to transmit the SQL text to the database engine for execution.
                In the latter case (you end an SQL Statement with a blank 
                line), the command will go to the edit buffer and SQL history, 
                but will not be executed (but you can execute it later from the 
                edit buffer).
                (See the note immediately above about multiple SQL statements 
                in one SqlTool command).
            </p><p>
                (Blank lines are only interpreted this way when SqlTool is
                run interactively.
                In SQL files, blank lines inside of SQL statements remain
                part of the SQL statement).
            </p><p>
                As a result of these termination rules, whenever you are 
                entering text that is not a Special Command, Edit Buffer /
                History Command, or PL Command, you are always 
                <span class="emphasis"><em>appending</em></span> lines to an SQL Statement
                or comment.
                (In the case of the first line, you will be appending to an
                empty SQL statement.  I.e. you will be starting a new SQL 
                Statement or comment).
            </p></dd><dt><span class="term">Special Command</span></dt><dd>
                Run the command "\?" to list the Special Commands.
                All of the Special Commands begin with "\".
                I'll describe some of the most 
                useful Special Commands below.
            </dd><dt><span class="term">Edit Buffer / History Command</span></dt><dd>
                Run the command ":?" to list the Edit-Buffer/History Commands.
                All of these commands begin with ":".
                These commands use commands from the command history, or
                operate upon the edit "buffer", so that 
                you can edit and/or (re-)execute previously entered commands.
            </dd><dt><span class="term">PL Command</span></dt><dd><p>
                Procedural Langage commands.
                Run the command "*?" to list the PL Commands.
                All of the PL Commands begin with "*".
                PL commands are for setting and using scripting variables
                and conditional and flow control statements like
                <tt class="literal">* if</tt> and <tt class="literal">* while</tt>.
                A few PL features (such as PL aliases and updating and
                selecing data directly from/to files) can be a real 
                convenience for nearly all users, so these features will be
                discussed briefly in this section.
                More detailed explanation of PL variables and the other 
                PL features, with examples, are covered in the
                <a href="ch08.html#pl-section" title="SqlTool Procedural Language">SqlTool Procedural Language</a> section.
            </p></dd><dt><span class="term">Raw Mode</span></dt><dd>
                The descriptions of command-types above do not apply to
                <a href="ch08.html#raw-section" title="Raw Mode">Raw Mode</a>.
                In raw mode, SqlTool
                doesn't interpret what you type at all.  It all just
                goes into the edit buffer which you can send to the database
                engine.
                Beginners can safely ignore raw mode.
                You will never encounter it unless you run the "\."
                special command, or enter a PL/SQL command.
                See the 
                <a href="ch08.html#raw-section" title="Raw Mode">Raw Mode</a> section
                for the details.
            </dd></dl></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="N115AE"></a>Special Commands</h2></div></div><div></div></div><div class="variablelist"><p class="title"><b>Essential Special Commands</b></p><dl><dt><span class="term">\?</span></dt><dd>
                help
            </dd><dt><span class="term">\q</span></dt><dd>
                quit
            </dd><dt><span class="term">\i path/to/script.sql</span></dt><dd>
                execute the specified SQL script, then continue again
                interactively.
            </dd><dt><span class="term">\=</span></dt><dd>
                commit the current SQL transaction.
                Most users are used to typing the SQL statement
                <tt class="literal">commit;</tt>, but this command is crucial for
                those databases which don't support the statement.
                It's obviously unnecessary if you have auto-commit mode on.
            </dd><dt><span class="term">\x?</span></dt><dd>
                List a summary of DSV eXporting, and all available DSV options.
            </dd><dt><span class="term">\m?</span></dt><dd>
                List a summary of DSV iMporting, and all available DSV options.
            </dd><dt><span class="term">\d?</span></dt><dd>
                List a summary of the \d commands below.
            </dd><dt><span class="term">\dt [filter_substring]</span></dt><dd></dd><dt><span class="term">\dv [filter_substring]</span></dt><dd></dd><dt><span class="term">\ds [filter_substring]</span></dt><dd></dd><dt><span class="term">\di [table_name]</span></dt><dd></dd><dt><span class="term">\dS [filter_substring]</span></dt><dd></dd><dt><span class="term">\da [filter_substring]</span></dt><dd></dd><dt><span class="term">\dn [filter_substring]</span></dt><dd></dd><dt><span class="term">\du [filter_substring]</span></dt><dd></dd><dt><span class="term">\dr [filter_substring]</span></dt><dd></dd><dt><span class="term">\d* [filter_substring]</span></dt><dd><p>
                Lists available objects of the given type.
                <div class="itemizedlist"><ul type="disc"><li>t: non-system Tables</li><li>v: Views</li><li>s: Sequences</li><li>i: Indexes</li><li>S: System tables</li><li>a: Aliases</li><li>n: schema Names</li><li>u: database Users</li><li>r: Roles</li><li>*: all table-like objects</li></ul></div>
                If your database supports schemas, then the schema name will
                also be listed.
                </p><p>
                If you supply an optional <span class="emphasis"><em>filter substring</em></span>,
                then only items which contain the given substring (in the object
                name or schema name) will be listed.
                </p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Important</h3><p>
                    The substring test is case-sensitive!
                    Even though in SQL queries and for the "\d objectname"
                    command object names are usually case-insensitive, for 
                    the \dX commands, you must capitalize the filter 
                    substring exactly as it will appear in the special
                    command output.
                    This is an inconvenience, since the database engine
                    will change names in SQL to default case unless you 
                    double-quote the name, but that is server-side 
                    functionality which cannot (portably) be reproduced by 
                    SqlTool.
                    You can use spaces and other special characters in
                    the string.
                </p></div><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Tip</h3><p>
                    Filter substrings ending with "." are special.
                    If a substring ends with ".", then this means to narrow
                    the search by the exact, case-sensitive schema name
                    given.
                    For example, if I run "\d* BLAINE.", this will list all
                    table-like database objects in the "BLAINE" schema.
                    The capitalization of the schema must be exactly the same 
                    as how the schema name is listed by the "\dn" command.
                    You can use spaces and other special characters in
                    the string.
                    (I.e., enter the name exactly how you would enter it 
                    inside of double-quotes in an SQL command).
                    This is an inconvenience, since the database engine
                    will change names in SQL to default case unless you 
                    double-quote the name, but that is server-side 
                    functionality which cannot (portably) be reproduced by 
                    SqlTool.
                </p></div><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Important</h3><p>
                    Indexes may not be searched for by 
                    <span class="emphasis"><em>substring</em></span>, only by
                    exact target table name.
                    So if <tt class="literal">I1</tt> is an index on table
                    <tt class="literal">T1</tt>, then you list this index by running
                    "\di T1".
                    In addition, many database vendors will report on indexes 
                    only if a target table is identified.
                    Therefore, "\di" with no argument will fail if your database
                    vendor does not support it.
                </p></div></dd><dt><span class="term">\d objectname [filter]</span></dt><dd><p>
                Lists names of columns in the specified table or view.
                <tt class="literal">objectname</tt> may be a base table name or
                a schema.object name.
                </p><p>
                If you supply a filter string, then only columns with a name
                containing the given filter will be listed.
                The objectname is nearly always case-insensitive (depends on
                your database), but the filter is always case-sensitive.
                You'll find this filter is a great convenience compared to
                other database utilities, where you have to list all columns
                of large tables when you are only interested in one of them.
                </p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Tip</h3><p>
                When working with real data (as opposed to learning or playing),
                I often find it useful to run two SqlTool sessions in two
                side-by-side terminal emulator windows.
                I do all of my real work in one window, and use the other
                mostly for \d commands.
                This way I can refer to the data dictionary while writing SQL
                commands, without having to scroll.
            </p></div></dd></dl></div><p>
            This list here includes only the <span class="emphasis"><em>essential</em></span> 
            Special Commands, but n.b. that there are other useful Special 
            Commands which you can list by running <tt class="literal">\?</tt>.
            (You can, for example, execute SQL from external SQL files, and 
            save your interactive SQL commands to files).
            Some specifics of these other commands are specified immediately 
            below, and the 
            <a href="ch08.html#report-section" title="Generating Text or HTML Reports">Generating Text or HTML Reports</a>
            section explains how to use the "\o" and "\H" special commands to 
            generate reports.
        </p><p>
            Be aware that the <tt class="literal">\!</tt> Special Command does
            not work for external programs that read from standard input.
            You can invoke non-interactive and graphical interactive programs, 
            but not command-line interactive programs.
        </p><p>
            SqlTool executes <tt class="literal">\!</tt> programs directly, it does 
            not run an operating system shell (this is to avoid OS-specific
            code in SqlTool).
            Because of this, you can give as many command-line arguments
            as you wish, but you can't use shell wildcards or redirection.
        </p><p>
            The \w command can be used to store any command in your SQL 
            history to a file.
            Just restore the command to the edit buffer
            with a command like "\-4" before you give the \w command.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="N11678"></a>Edit Buffer / History Commands</h2></div></div><div></div></div><div class="variablelist"><p class="title"><b>Edit Buffer / History Commands</b></p><dl><dt><span class="term">:?</span></dt><dd>
                help
            </dd><dt><span class="term">:b</span></dt><dd>
                List the current contents of the edit buffer.
            </dd><dt><span class="term">:h</span></dt><dd>
                Shows the Command History.
                For each command which has been executed (up to the max
                history length), the SQL command history will show the 
                command; its command number (#); and also how many commands
                <span class="emphasis"><em>back</em></span> it is (as a negative number).
                : commands are never added to the history list.
                You can then use either form of the command identifier to
                recall a command to the edit buffer (the command described
                next) or as the target of any of the following : commands.
                This last is accomplished in a manner very similar to the
                vi editor.
                You specify the target command number between the colon 
                and the command.
                As an example, if you gave the command
                <tt class="literal">:s/X/Y/</tt>, that would perform the
                substitution on the contents of the edit buffer; but if you
                gave the command <tt class="literal">:-3 s/X/Y/</tt>, that would
                perform the substitution on the command 3 back in the 
                command history (and copy the output to the edit buffer).
                Also, just like vi, you can identify the command to recall
                by using a regular expression inside of slashes, like
                <tt class="literal">:/blue/ s/X/Y/</tt> to operate on the last
                command you ran which contains "blue".
            </dd><dt><span class="term">:13  OR  :-2  OR   :/blue/</span></dt><dd><p>
                Recalls a command from Command history to the edit buffer.
                Enter ":" followed by the positive command number from 
                Command history, like ":13"...  or ":" followed by a negative
                number like ":-2" for two commands back in the Command
                history... or ":" followed by a regular expression inside
                slashes, like ":/blue/" to recall the last command which
                contains "blue".
                The specified command  will be written to the edit buffer 
                so that you can execute it or edit it using the commands below.
                </p><p>
                As described under the :h command immediately above,
                you can follow the command number here with
                any of the commands below to perform the given operation
                on the specified command from history instead of on the
                edit buffer contents.
                So, for example, ":4;" would load command 4 from history
                then execute it (see the ":;" command below).
            </p></dd><dt><span class="term">:;</span></dt><dd>
                Executes the SQL, Special or PL statement in the edit buffer
                (by default).
                This is an extremely useful command.
                It's easy to remember because it consists of ":", meaning
                <span class="emphasis"><em>Edit Buffer Command</em></span>, plus a
                line-terminating ";", (which generally means to execute an
                SQL statement, though in this case it will also execute a
                special or PL command).
            </dd><dt><span class="term">:a</span></dt><dd><p>
                Enter append mode with the contents of the edit buffer (by
                default) as the current command.
                When you hit ENTER, things will be exactly as if you 
                physically re-typed the command that is in the edit buffer.
                Whatever lines you type next will be appended to the immediate
                command.
                As always, you then have the choice of hitting ENTER to 
                execute a Special or PL command, entering a blank line to
                store back to the edit buffer, or end a SQL statement with
                semi-colon and ENTER to execute it.
                </p><p>
                You can, optionally, put a string after the :a, in which
                case things will be exactly as just described except the
                additional text will also be appended to the new immediate
                command.
                If you put a string after the :a which ends with ;, then
                the resultant new immediate command will just be executed
                right away, as if you typed in and entered the entire thing.
                </p><p>
                If your edit buffer contains
                <tt class="literal">SELECT x FROM mytab</tt> and you run
                <tt class="literal">a:le</tt>, the resultant command will be
                <tt class="literal">SELECT x FROM mytable</tt>.
                If your edit buffer contains
                <tt class="literal">SELECT x FROM mytab</tt> and you run
                <tt class="literal">a: ORDER BY y</tt>, the resultant command will be
                <tt class="literal">SELECT x FROM mytab ORDER BY y</tt>.
                Notice that in the latter case the append text begins with a
                space character.
            </p></dd><dt><span class="term">:s/from regex/to string/switches</span></dt><dd><p>
                The Substitution Command is the primary method for SqlTool 
                command editing-- it operates upon the current edit buffer
                by default.
                The "to string" and the "switches" are both optional (though
                the final "/" is not).
                To start with, I'll discuss the use and behavior if you don't
                supply any substitution mode switches.
                </p><p>
                Don't use "/" if it occurs in either "from string" or "to 
                string".
                You can use any character that you want in place of "/", but 
                it must not occur in the <span class="emphasis"><em>from</em></span> or 
                <span class="emphasis"><em>to</em></span> strings.
                Example
                <div class="informalexample"><pre class="screen">
    :s@from string@to string@</pre></div></p><p>
                The <span class="emphasis"><em>to string </em></span> is substituted for the first 
                occurrence of the (case-specific)
                <span class="emphasis"><em>from string</em></span>.
                The replacement will consider the entire SQL statement, even
                if it is a multi-line statement.
                </p><p>
                In the example above, the from regex was a plain string, but
                it is interpreted as a regular expression so you can do
                all kinds of powerful substitutions.
                See the <tt class="literal">perlre</tt> man page, or the
                <a href="http://http://java.sun.com/javase/6/docs/api/java/util/regex/Pattern.html" target="_top">java.util.regex.Pattern</a>
                API Spec for everything you need to know about extended
                regular expressions.
                </p><p>
                Don't end a <span class="emphasis"><em>to</em></span> string with ";" in attempt
                to make a command execute.
                There is a substitution mode switch to use for that purpose.
                </p><p>
                You can use any combination of the substitution mode switches.
                <div class="itemizedlist"><ul type="disc"><li><p>
                        Use "i" to make the searches for 
                        <span class="emphasis"><em>from regex</em></span> case insensitive.
                    </p></li><li><p>
                        Use "g" to substitute Globally, i.e., to subsitute
                        <span class="emphasis"><em>all</em></span> occurrences of the
                        <span class="emphasis"><em>from regex</em></span> instead of only the
                        first occurrence found.
                    </p></li><li><p>
                        Use ";" to execute the command immediately after the
                        substitution is performed.
                    </p></li><li><p>
                        Use "m" for ^ and $ to match each line-break in a
                        multi-line edit buffer, instead of just at the very
                        beginning and every end of the entire buffer.
                    </p></li></ul></div>
            </p><p>
                If you specify a command number (from the command history),
                you end up with a feature very reminiscent of vi, but even
                more powerful, since the Perl/Java regular expression are
                a superset of the vi regular expressions.
                As an example,
                <div class="informalexample"><pre class="screen">
                    :24 s/pin/needle/g;
                    </pre></div> would start with command number 24 from
                command history, substitute "needle" for all occurrences of
                "pin", then execute the result of that substitution
                (and this final statement will of course be copied to the
                edit buffer and to command history).
            </p></dd><dt><span class="term">:w /path/to/file.sql</span></dt><dd>
                This appends the contents of the current buffer (by default)
                to the specified file.
                Since what is being written are Special, PL, or SQL commands,
                you are effectively creating an SQL script.
            </dd></dl></div><p>
            I find the ":/regex/"  and ":/regex/;" constructs particularly
            handy for every-day usage.
            <div class="informalexample"><pre class="screen">
                    :/\\d/;</pre></div>re-executes the last \d command that you gave
            (The extra "\" is needed to escape the special meaning of "\"
            in regular expressions).
            It's great to be able to recall and execute the last "insert"
            command, for example, without needing to check the history or
            keep track of how many commands back it was.  To re-execute
            the last insert command, just run ":/insert/;".
            If you want to be safe about it, do it in two steps to verify
            that you didn't accidentally recall some other command which
            happened to contain the string "insert", like
            <div class="informalexample"><pre class="screen">
    :/insert/
    :;</pre></div>(Executing the last only if you are
            satisfied when SqlTool reports what command it restored).
            Often, of course, you will want to change the command before
            re-executing, and that's when you combine the :s and :a commands.
        </p><p>
            We'll finish up with a couple fine points about Edit/Buffer
            commands.
            You generally can't use PL variables in Edit/Buffer commands, to
            eliminate possible ambiguities and complexities when modifying
            commands.
            The :w command is an exception to this rule, since it can be
            useful to use variables to determine the output file, and this
            command does not do any "editing".
        </p><p>
            The :? help explains how you can change the default regular 
            expression matching behavior (case sensitivity, etc.), but
            you can always use syntax like "(?i)" inside of your regular
            expression, as described in the Java API spec for class
            <tt class="classname">java.util.regex.Pattern</tt>, found
            <a href="http://http://java.sun.com/javase/6/docs/api/java/util/regex/Pattern.html" target="_top">here</a>.
            History-command-matching with the /regex/ construct is 
            purposefully liberal, matching any portion of the command,
            case sensitive, etc., but you can still use the method just
            described to modify this behavior.  In this case, you could
            use "(?-i)" at the beginning of your regular expression to
            be case-sensitive.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="interactive_pl_commands-section"></a>PL Commands</h2></div></div><div></div></div><div class="variablelist"><p class="title"><b>Essential PL Command</b></p><dl><dt><span class="term">* VARNAME = value</span></dt><dd><p>
                Set the value of a variable.
                If the variable doesn't exist yet, it will be created.
                The most common use for this is so that you can later use
                it in SQL statements, print statements, and PL conditionals,
                by using the <tt class="literal">*{VARNAME}</tt> or
                <tt class="literal">*{:VARNAME}</tt> construct.
                The only difference between <tt class="literal">*{VARNAME}</tt> and
                <tt class="literal">*{:VARNAME}</tt> is that the former produces an
                error if VARNAME is not set, whereas the latter will expand
                to a zero-length string if VARNAME is not set.
            </p><p>
                    If you set a variable to an SQL statement (without the
                    terminating ";") you can then use it as a PL alias like
                    <tt class="literal">/VARNAME</tt>, as shown in this example.
                <div class="example"><a name="alias-example"></a><p class="title"><b>Example&nbsp;8.2.&nbsp;Defining and using a PL alias (PL variable)</b></p><pre class="screen">
    * qry = SELECT COUNT(*) FROM mytable
    \p The stored query is '*{qry}'
    /qry;
    /qry WHERE mass &gt; 200;</pre></div>
            </p><p>
                If you put variable definitions into the SQL file
                <tt class="filename">auto.sql</tt> in your home directory, those
                aliases/variables will always be available for interactive use.
            </p><p>
                PL variables can be expanded within all commands other than
                : edit/history commands.
            </p></dd><dt><span class="term">* load VARNAME /file/path.txt</span></dt><dd>
                Sets VARNAME to the content of the specified ASCII file.
            </dd><dt><span class="term">* prepare VARNAME</span></dt><dd>
                Indicate that next command should be a SQL INSERT or UPDATE
                command containing one question mark.
                The value of VARNAME will be substuted for the ? variable.
                This does work for CLOB columns.
            </dd><dt><span class="term">* VARNAME _</span></dt><dd>
                When next SQL command is run, instead of displaying the rows,
                just store the very first column value to variable VARNAME.
                This works for CLOB columns too.
                It also works with Oracle XML type columns if you use
                column labels and the <tt class="literal">getclobval</tt> function.
            </dd><dt><span class="term">* VARNAME ~</span></dt><dd>
                Exactly the same as <pre class="programlisting">* VARNAME ~</pre>
                except that the fetched results will be displayed in addition
                to setting the variable.
            </dd><dt><span class="term">* dump VARNAME /file/path.txt</span></dt><dd>
                Store the value of VARNAME to the specified ASCII file.
            </dd></dl></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="N11792"></a>? Variable</h3></div></div><div></div></div><p>
            You don't set the ? variable.
            It is just like the Bourne shell variable ? in that it is always
            automatically set to the first value of a result set (or the
            return value of other SQL commands).
            It works just like the <pre class="programlisting">* VARNAME ~</pre>
            command described above, but it all happens automatically.
            You can, of course, dereference ? like any PL variable, but it
            does not list with the <pre class="programlisting">list</pre> and
            <pre class="programlisting">listvalues</pre> commands.
            You can see the value whenever you want by running
            <div class="informalexample"><pre class="programlisting">
    \p  *{?}</pre></div>
          </p><p>
            Note that PL commands are used to upload and download column
            values to/from local ASCII files, but the corresponding actions 
            for binary files use the special \b commands.
            This is because PL variables are used for ASCII values and
            you can store any number of column values in PL variables.
            This is not true for binary column values.
            The \b commands work with a single binary byte buffer.
        </p><p>
            See the <a href="ch08.html#pl-section" title="SqlTool Procedural Language">SqlTool Procedural Language</a> section 
            below for information on using variables in other ways, and 
            information on the other PL commands and features.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="binary_files-section"></a>
                Storing and retrieving binary files</h3></div></div><div></div></div><p>
            You can upload binary files such as photographs, audio files,
            or serialized Java objects into database columns.
            SqlTool keeps one binary buffer which you can load from files
            with the \bl command, or from a database query by doing a
            one-row query for any non-displayable type (including
            <tt class="literal">BLOB</tt>, <tt class="literal">OBJECT</tt>, and
            <tt class="literal">OTHER</tt>).
            In the latter case, the data returned for the first
            non-displayable column of the first result row will be stored 
            into the binary buffer.
        </p><p>
            Once you have data in the binary buffer, you can upload it
            to a database column (including <tt class="literal">BLOB</tt>,
            <tt class="literal">OBJECT</tt>, and <tt class="literal">OTHER</tt> type
            columns), or save it to a file.
            The former is accomplished by the special command \bp followed
            by a <span class="emphasis"><em>prepared</em></span> SQL query containing one 
            question mark place-holder to indicate where the data gets
            inserted.
            The latter is accomplished with the \bd command.
        </p><p>
            You can also store the output from normal, displayable column
            into the binary buffer by using the special command \b.
            The very first column value from the first result row of the
            next SQL command will be stored to the binary byte buffer.
        </p><div class="example"><a name="N117D6"></a><p class="title"><b>Example&nbsp;8.3.&nbsp;Inserting binary data into database from a file</b></p><pre class="screen">
    \bl /tmp/favoritesong.mp3
    \bp
    INSERT INTO musictbl (id, stream) VALUES(3112, ?);</pre></div><div class="example"><a name="N117DC"></a><p class="title"><b>Example&nbsp;8.4.&nbsp;Downloading binary data from database to a file</b></p><pre class="screen">
    SELECT stream FROM musictbl WHERE id = 3112;
    \bd /tmp/favoritesong.mp3</pre></div><p>
            You can also store and retrieve text column values to/from
            ASCII files, as documented in the
            <a href="ch08.html#interactive_pl_commands-section" title="PL Commands">Essential PL Command</a>
            section.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="N117E8"></a>Command History</h3></div></div><div></div></div><p>
            The SQL history shown by the \h command, and used by other commands,
            is truncated to 100 entries, since its utility comes from being 
            able to quickly view the history list.
            You can change the history length by setting the system property
            <tt class="literal">sqltool.historyLength</tt> to an integer like
            <pre class="screen">
java -Dsqltool.historyLength=100 -jar $HSQLDB_HOME/lib/hsqldb.jar urlid</pre>
            If there is any demand, I'll make the setting of this value more
            convenient.
        </p><p>
            The SQL history list contains all executed commands other than
            Edit Buffer commands and comments, even if the command has a
            syntax error or fails upon execution.
            The reason for including bad commands is so that you can 
            recall and fix them if you wish to.
            The same applies to the edit buffer.
            If you copy a command to the edit buffer by entering blank
            line, or if you edit the edit buffer, that edit buffer value 
            will never make it into the command history until and if 
            you execute it.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="N117F7"></a>Shell scripting and command-line piping</h3></div></div><div></div></div><p>
            You normally use non-interactive mode for input piping.
            You specify "-" as the SQL file name.  
            See the <a href="ch08.html#scripting-section" title="Piping and shell scripting">Piping and shell scripting</a>
            subsection of the Non-Interactive chapter.
            </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="N11800"></a>Emulating Non-Interactive mode</h3></div></div><div></div></div><p>
            You can run SqlTool <span class="emphasis"><em>interactively</em></span>, but
            have SqlTool behave exactly as if it were processing an SQL
            file (i.e., no command-line prompts, error-handling
            that defaults to fail-upon-error, etc.).
            Just specify "-" as the SQL file name in the command line.
            This is a good way to test what SqlTool will do when it 
            encounters any specific command in an SQL file.
            See the <a href="ch08.html#scripting-section" title="Piping and shell scripting">Piping and shell scripting</a>
            subsection of the Non-Interactive chapter for an example.
            </p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="nonint-section"></a>Non-Interactive</h2></div></div><div></div></div><p>
            Read the <a href="ch08.html#int-section" title="Interactive Usage">Interactive Usage</a>
            section if you have not already, 
            because much of what is in this section builds upon that.
            You can skip all discussion about Command History and the
            edit buffer if you will not use those interactive features.
        </p><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Important</h3><p>
            If you're doing data updates, remember to issue a commit command
            or use the <tt class="literal">--autoCommit</tt> switch.
        </p></div><p>
            As you'll see, SqlTool has many features that are very 
            convenient for scripting.  But what really makes it superior for
            automation tasks (as compared to SQL tools from other vendors)
            is the ability to reliably detect errors and to control JDBC
            transactions.
            SqlTool is designed so that you can reliably determine if errors 
            occurred within SQL scripts themselves, and from the invoking
            environment (for example, from a perl, Bash, or Python script,
            or a simple cron tab invocation).
        </p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="sqlswitch-section"></a>Giving SQL on the Command Line</h3></div></div><div></div></div><p>
                If you just have a couple Commands to run, you can run them 
                directly from the comand-line or from a shell script without an 
                SQL file, like this.
            <div class="informalexample"><pre class="screen">
    java -jar $HSQLDB_HOME/lib/hsqldb.jar --sql 'SQL statement;' urlid</pre></div>
            <div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
                The <tt class="literal">--sql</tt> automatically implies
                <tt class="literal">--noinput</tt>, so if you want to execute the
                specified SQL before <span class="emphasis"><em>and in addition to</em></span> an
                interactive session (or stdin piping), then you must also give
                the <span class="emphasis"><em>--stdinput</em></span> switch.
            </p></div>
            </p><p>
                Since SqlTool transmits SQL statements to the database engine
                only when a line is terminated with ";", if you want feedback
                from multiple SQL statements in an --sql expression, you will
                need to use functionality of your OS shell to include
                linebreaks after the semicolons in the expression.
                With any Bourne-compatible shell, you can include linebreaks in 
                the SQL statements like this.
            <div class="informalexample"><pre class="screen">
    java -jar $HSQLDB_HOME/lib/hsqldb.jar --sql '
        SQL statement number one;
        SQL statement
            number two;
        SQL statement three;
    ' urlid</pre></div>
                If you don't need feedback, just separate the SQL commands
                with semicolons and the entire expression will be
                <a href="ch08.html#chunk-section" title="Chunking">chunked</a>.
            </p><p>
                The <span class="emphasis"><em>--sql</em></span> switch is very useful for 
                setting shell variables to the output of SQL Statements, like 
                this.
            <div class="informalexample"><pre class="programlisting">
    # A shell script
    USERCOUNT=`java -jar $HSQLDB_HOME/lib/hsqldb.jar --sql '
        select count(*) from usertbl;
    ' urlid` || {
        # Handle the SqlTool error
    }
    echo "There are $USERCOUNT users registered in the database."
    [ "$USECOUNT" -gt 3 ] &amp;&amp; {   # If there are more than 3 users registered
        # Some conditional shell scripting</pre></div>
            </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="N11853"></a>SQL Files</h3></div></div><div></div></div><p>
                Just give paths to sql text file(s) on the command line after 
                the <span class="emphasis"><em>urlid</em></span>.
            </p><p>
                Often, you will want to redirect output to a file, like
            <div class="informalexample"><pre class="screen">
java -jar $HSQLDB_HOME/lib/hsqldb.jar sql... &gt; /tmp/log.sql 2&gt;&amp;1</pre></div></p><p>
                (Skip the "2&gt;&amp;1" if you're on Windows).
            </p><p>
                You can also execute SQL files from an interactive session with
                the "\i"' Special Command,
                but be aware that the default behavior in an interactive 
                session is to continue upon errors.
                If the SQL file was written without any concern for error
                handling, then the file will continue to execute after errors
                occur.
                You could run <tt class="literal">\c false</tt> before 
                <tt class="literal">\i filename</tt>, but then your SqlTool session
                will exit if an error is encountered in the SQL file.
                If you have an SQL file without error handling, and you want
                to abort that file when an error occurs, but not exit 
                SqlTool, the easiest way to accomplish this is usually to add
                <tt class="literal">\c false</tt> to the top of the script.
            </p><p>
                If you specify multiple SQL files on the command-line, the
                default behavior is to exit SqlTool immediately if any of 
                the SQL files encounters an error.
            </p><p>
                <span class="bold"><b>
                SQL files themselves have ultimate control over error handling.
                </b></span>
                Regardless of what command-line options are set, or what 
                commands you give interactively, if a SQL file gives error
                handling statements, they will take precedence.
            </p><p>
                You can also use \i in SQL files.
                This results in nested SQL files.
            </p><p>
                You can use the following SQL file,
                <tt class="filename">sample.sql</tt>, which resides in the
                <tt class="filename">sample</tt> directory of your
                HSQLDB distribution
                <sup>[<a href="#ftn.samplelocFn">1</a>]</sup>.
                It contains SQL as well as Special Commands making good
                use of most of the Special Commands documented below.
            </p><pre class="programlisting">/*
    $Id: sample.sql,v 1.4 2005/02/25 23:34:30 fredt Exp $
    Examplifies use of SqlTool.
    PCTASK Table creation
*/

/* Ignore error for these two statements */
\c true
DROP TABLE pctasklist;
DROP TABLE pctask;
\c false

\p Creating table pctask
CREATE TABLE pctask (
    id integer identity,
    name varchar(40),
    description varchar,
    url varchar,
    UNIQUE (name)
);

\p Creating table pctasklist
CREATE TABLE pctasklist (
    id integer identity,
    host varchar(20) not null,
    tasksequence int not null,
    pctask integer,
    assigndate timestamp default current_timestamp,
    completedate timestamp,
    show bit default true,
    FOREIGN KEY (pctask) REFERENCES pctask,
    UNIQUE (host, tasksequence)
);

\p Granting privileges
GRANT select ON pctask TO public;
GRANT all ON pctask TO tomcat;
GRANT select ON pctasklist TO public;
GRANT all ON pctasklist TO tomcat;

\p Inserting test records
INSERT INTO pctask (name, description, url) VALUES (
    'task one', 'Description for task 1', 'http://cnn.com');
INSERT INTO pctasklist (host, tasksequence, pctask) VALUES (
    'admc-masq', 101, SELECT id FROM pctask WHERE name = 'task one');

commit;
</pre><p>
                You can execute this SQL file with a Memory Only database with 
                a command like
            <div class="informalexample"><pre class="programlisting">
    java -jar $HSQLDB_HOME/lib/hsqldb.jar  --sql '
        create user tomcat password "x";
    ' mem path/to/hsqldb/sample/sample.sql</pre></div>
            </p><p>
                (The <tt class="literal">--sql "create...;"</tt> arguments create an
                account which the script uses).
                You should see error messages betwen the
                <tt class="literal">Continue-on-error...true</tt> and
                <tt class="literal">Continue-on-error...false</tt>.  The script
                purposefully runs commands that might fail there.
                The reason the script does this is to perform
                database-independent conditional table removals.
                (The SQL clause <tt class="literal">IF EXISTS</tt> is more graceful
                and succinct, and should be used if you don't need to support
                databases which don't support <tt class="literal">IF EXISTS</tt>).
                If an error occurs when continue-on-error is false, the
                script would abort immedately.
            </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="scripting-section"></a>Piping and shell scripting</h3></div></div><div></div></div><p>
                You can of course, redirect output
                <span class="emphasis"><em>from</em></span> SqlTool to a file
                or another program.
            <div class="informalexample"><pre class="screen">
    java -jar $HSQLDB_HOME/lib/hsqldb.jar urlid file.sql &gt; file.txt 2&gt;&amp;1

    java -jar $HSQLDB_HOME/lib/hsqldb.jar urlid file.sql 2&gt;&amp;1 | someprogram...</pre></div></p><p>
                You can type commands in to SqlTool while being in 
                non-interactive mode by supplying "-" as the file name.
                This is a good way to test how SqlTool will behave when 
                processing your SQL files.
            <div class="informalexample"><pre class="screen">
        java -jar $HSQLDB_HOME/lib/hsqldb.jar urlid -</pre></div></p><p>
                This is how you have SqlTool read its input from another 
                program:
            <div class="example"><a name="N118BE"></a><p class="title"><b>Example&nbsp;8.5.&nbsp;Piping input into SqlTool</b></p><pre class="screen">
        echo "Some SQL commands with '$VARIABLES';" |
        java -jar $HSQLDB_HOME/lib/hsqldb.jar urlid -</pre></div></p><p>
                Make sure that you also read the
                <a href="ch08.html#sqlswitch-section" title="Giving SQL on the Command Line">Giving SQL on the Command Line</a>
                section.
                The <tt class="literal">--sql</tt> switch is a great facility to use
                with shell scripts.
            </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="N118CE"></a>Optimally Compatible SQL Files</h3></div></div><div></div></div><p>
                If you want your SQL scripts optimally compatible among other
                SQL tools, then don't use any Special or PL Commands.
                SqlTool has default behavior which I think is far superior to 
                the other SQL tools, but you will have to disable these 
                defaults in order to have optimally compatible behavior.
            </p><p>
                These switches provide compatibilty at the cost of poor 
                control and error detection.
                <div class="itemizedlist"><ul type="disc"><li><p>
                            --continueOnErr
                        </p><p>
                            The output will still contain error messages about
                            everything that SqlTool doesn't like
                            (malformatted commands, SQL command failures, 
                            empty SQL commands), but SqlTool will continue to
                            run.
                            Errors will not cause rollbacks (but that won't
                            matter because of the following setting).
                        </p></li><li>--autoCommit</li></ul></div>
            </p><p>
                You don't have to worry about accidental expansion of 
                PL variables, since SqlTool will never expand PL variables
                if you don't set any variables on the command line, or give 
                any "* " PL commands.
                (And you could not have "* " commands in a compatible SQL 
                file).
            </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="N118E1"></a>Comments</h3></div></div><div></div></div><p>
                SQL comments of the form <tt class="literal">/*...*/</tt> must begin
                where a (SQL/Special/Edit-Buffer/PL) Command could begin, and 
                they end with the very first "*/" (regardless of quotes, 
                nesting, etc.
                You may have as many blank lines as you want inside of a
                comment.
            </p><div class="example"><a name="N118EA"></a><p class="title"><b>Example&nbsp;8.6.&nbsp;Valid comment example</b></p><pre class="programlisting">
    SELECT count(*) FROM atable;
    /* Lots of
     comments interspersed among
     several lines */   SELECT count(*)
    FROM btable;</pre></div><p>
                Notice that a command can start immediate after the comment
                ends.
            </p><div class="example"><a name="N118F2"></a><p class="title"><b>Example&nbsp;8.7.&nbsp;Invalid comment example</b></p><pre class="programlisting">
    SELECT count(*) FROM
    /* atable */
    btable;</pre></div><p>
                This comment is invalid because you could not start another
                command at the comment location (because it is within an SQL
                Statement).
            </p><p>
                You can try using <tt class="literal">/*...*/</tt> in other locations,
                and <tt class="literal">--</tt> style SQL comments, but SqlTool will
                not treat them as comments.
                If they occur within an SQL Statment, SqlTool will pass them to
                the database engine, and the DB engine will determine whether
                to parse them as comments.
            </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="N11904"></a>Special Commands and Edit Buffer Commands in SQL Files</h3></div></div><div></div></div><p>
                Don't use Edit Buffer / History Commands in your sql files, 
                because they won't work.
                Edit Buffer / History Commands are for interactive use only.
                (But, see the 
                <a href="ch08.html#raw-section" title="Raw Mode">Raw Mode</a> section 
                for an exception).
                You can, of course, use any SqlTool command at all
                interactively.
                I just wanted to group together the commands most useful to
                script-writers.
            </p><div class="variablelist"><dl><dt><span class="term">\q [abort message]</span></dt><dd><p>
                    Be aware that the \q command will cause SqlTool to 
                    completely exit.
                    If a script <tt class="filename">x.sql</tt> has a \q command in
                    it, then it doesn't matter if the script is executed like
                    <pre class="screen">
    java -jar .../hsqldb.jar urlid a.sql x.sql z.sql</pre> or if you use
                    \i to read it in interactively, or if another SQL file
                    uses \i to nest it.
                    If \q is encountered, SqlTool will quit.
                    See the <a href="ch08.html#pl-section" title="SqlTool Procedural Language">SqlTool Procedural Language</a> 
                    section for commands to abort an SQL file (or even parts
                    of an SQL file) without causing SqlTool to exit.
                </p><p>
                    \q takes an optional argument, which is an abort message.
                    If you give an abort message, the message is displayed to
                    the user and SqlTool will exit with a failure status.
                    If you give no abort message, then SqlTool will exit 
                    quietly with successful status.
                    As a result, <pre class="programlisting">\q</pre> means to
                    make an immediate but graceful exit, whereas
                    <pre class="programlisting">\q Message</pre> means to abort
                    immediately.
                </p></dd><dt><span class="term">\p [text to print]</span></dt><dd>
                    Print the given string to stdout.
                    Just give "\p" alone to print a blank line.
                </dd><dt><span class="term">\i /path/to/file.sql</span></dt><dd>
                    Include another SQL file at this location.
                    You can use this to nest SQL files.
                    For database installation scripts I often have a master
                    SQL file which includes all of the other SQL files in the
                    correct sequence.
                    Be aware that the current continue-upon-error behavior
                    will apply to included files until such point as the SQL
                    file runs its own error handling commands.
                </dd><dt><span class="term">\o [file/path.txt]</span></dt><dd><p>
                    Tee output to the specified file (or stop doing so).
                    See the
                    <a href="ch08.html#report-section" title="Generating Text or HTML Reports">Generating Text or HTML Reports</a> 
                    section.
                </p></dd><dt><span class="term">\=</span></dt><dd>
                    A database-independent way to commit your SQL session.
                </dd><dt><span class="term">\a [true|false]</span></dt><dd>
                    This turns on and off SQL transaction autocommits.
                    Auto-commit defaults to false, but you can change that
                    behavior by using the <tt class="literal">--autoCommit</tt>
                    command-line switch.
                </dd><dt><span class="term">\c [true|false]</span></dt><dd><p>
                    A "true" setting tells SqlTool to Continue when errors are 
                    encountered.
                    The current transaction will not be rolled back upon SQL
                    errors, so if \c is true, then run the
                    <tt class="literal">ROLLCACK;</tt> command yourself if that's 
                    what you want to happen.
                    The default for interactive use is to continue upon error, 
                    but the default for non-interactive use is to abort upon 
                    error.
                    You can override this behavior by using the
                    <tt class="literal">--continueOnErr</tt> or the
                    <tt class="literal">--abortOnErr</tt> command-line switch.
                    </p><p>
                    With database setup scripts, I usually find it convenient 
                    to set "true" before dropping tables (so that things will 
                    continue if the tables aren't there), then set it back to 
                    false so that real errors are caught.
                    <tt class="literal">DROP TABLE tablename IF EXISTS;</tt>
                    is a more elegant, but less portable, way to accomplish
                    the same thing.
                    </p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Tip</h3><p>
                        It depends on what you want your SQL files to do, of
                        course, but I usually want my SQL files to abort when
                        an error is encountered, without necessarily killing 
                        the SqlTool session.
                        If this is the behavior that you want, then
                        put an explicit <tt class="literal">\c false</tt>
                        at the top of your SQL file and turn on
                        continue-upon-error only for sections where you really
                        want to permit errors, or where you are using PL
                        commands to handle errors manually.
                        This will give the desired behavior whether your 
                        script is called by
                        somebody interactively, from the SqlTool command-line, 
                        or included in another SQL file (i.e. nested).
                    </p></div><div class="important" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Important</h3><p>
                        The default settings are usually best for people who 
                        don't want to put in any explicit \c or error handling 
                        code at all.
                        If you run SQL files from the SqlTool command line,
                        then any errors will cause SqlTool to roll back and
                        abort immediately.
                        If you run SqlTool interactively and invoke SQL files
                        with \i commands, the scripts will continue to run
                        upon errors (and will not roll back).
                        This behavior was chosen because there are lots of
                        SQL files out there that produce errors which can be
                        ignored; but we don't want to ignore errors that a
                        user won't see.
                        I reiterate that any and all of this behavior can (and 
                        often should) be changed by Special Commands run in 
                        your interactive shell or in the SQL files.
                        Only you know whether errors in your SQL files can
                        safely be ignored.
                    </p></div></dd></dl></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="N11972"></a>Automation</h3></div></div><div></div></div><p>
                SqlTool is ideal for mission-critical automation because,
                unlike other SQL tools, SqlTool returns a dependable exit 
                status and gives you control over error handling and SQL 
                transactions.
                Autocommit is off by default, so you can build a completely
                dependable solution by intelligently using \c commands 
                (Continue upon Errors) and commit statements, and by
                verifying exit statuses.
            </p><p>
                Using the SqlTool Procedural Language, you have ultimate
                control over program flow, and you can use variables for
                database input and output as well as for many other purposes.
                See the <a href="ch08.html#pl-section" title="SqlTool Procedural Language">SqlTool Procedural Language</a>
                section.
            </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="N1197D"></a>Getting Interactive Functionality with SQL Files</h3></div></div><div></div></div><p>
                Some script developers may run into cases where they want to 
                run with sql files but they alwo want SqlTool's interactive 
                behavior.
                For example, they may want to do command recall in the sql file,
                or they may want to log SqlTool's command-line prompts (which 
                are not printed in non-interactive mode).
                In this case, do not give the sql file(s) as an argument to 
                SqlTool, but pipe them in instead, like
            <div class="informalexample"><pre class="screen">
java -jar $HSQLDB_HOME/lib/hsqldb.jar urlid &lt; filepath1.sql &gt; /tmp/log.html 2&gt;&amp;1</pre></div>
                or
            <div class="informalexample"><pre class="screen">
cat filepath1.sql... |
java -jar $HSQLDB_HOME/lib/hsqldb.jar urlid &gt; /tmp/log.html 2&gt;&amp;1</pre></div>
            </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="charencoding-section"></a>
                Character Encoding</h3></div></div><div></div></div><p>
                SqlTool defaults to the US-ASCII character set (for reading).
                You can use another character set by setting the system 
                property <span class="property">sqlfile.charset</span>, like
            <div class="informalexample"><pre class="screen">
java -Dsqlfile.charset=UTF-8 -jar $HSQLDB_HOME/lib/hsqldb.jar urlid file.sql...</pre></div></p><p>
                You can also set this per urlid in the SqlTool configuration 
                file.
                See the <a href="ch08.html#auth-section" title="RC File Authentication Setup">RC File Authentication Setup</a>
                section about that.
            </p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="report-section"></a>Generating Text or HTML Reports</h2></div></div><div></div></div><p>
            This section is about making a file containing the output of 
            database queries.
            You can generate reports by using operating system facilities
            such as redirection, tee, and cutting and pasting.
            But it is much easier to use the "\o" and "\H" special commands.
        </p><div class="procedure"><p class="title"><b>Procedure&nbsp;8.4.&nbsp;Writing query output to an external file</b></p><ol type="1"><li><p>
                By default, everthing will be done in plain text.
                If you want your report to be in HTML format, then give the
                special command <tt class="literal">\H</tt>.
                If you do so, you will probably want to use filenames with an
                suffix of ".html" or ".htm" instead of ".txt" in the next step.
            </p></li><li><p>
                Run the command <tt class="literal">\o path/to/reportfile.txt</tt>.
                From this point on, output from your queries will be appended
                to the specified file.
                (I.e. another <span class="emphasis"><em>copy</em></span> of the output is
                generated.)
                This way you can continue to monitor or use output as usual as
                the report is generated.
            </p></li><li><p>
                When you want SqlTool to stop writing to the file, run
                <tt class="literal">\o</tt> (or just quit SqlTool if you have no 
                other work to do).
            </p></li><li><p>
                If you turned on HTML mode with <tt class="literal">\H</tt> before,
                you can run <tt class="literal">\H</tt> again to turn it back off,
                if you wish.
            </p></li></ol></div><p>
            It is not just the output of "SELECT" statements that will make
            it into the report file, but
            <div class="itemizedlist"><p class="title"><b>Kinds of output that get teed to \o files</b></p><ul type="disc"><li>
                    Output of SELECT statements.
                </li><li>
                    Output of all "\d" Special Commands.
                    (I.e., "\dt", "\dv", etc., and "\d OBJECTNAME").
                </li><li>
                    Output of "\p" Special Commands.
                    You will want to use this to add titles, and perhaps
                    spacing, for the output of individual queries.
                </li></ul></div>
            Other output will go to your screen or stdout, but will not make
            it into the report file.
            Be aware that no error messages will go into the report file.
            If SqlTool is run non-interactively (including if you give any
            SQL file(s) on the command line), SqlTool will abort with an error
            status if errors are encountered.
            The right way to handle errors is to check the SqlTool exit status.
            (The described error-handling behavior can be modified with
            SqlTool command-line switches and Special Commands).
        </p><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Warning</h3><p>
            Remember that \o <span class="emphasis"><em>appends</em></span> to the named file.
            If you want a new file, then use a new file name or remove the
            pre-existing target file ahead of time.
        </p></div><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Tip</h3><p>
            So that I don't end up with a bunch of junk in my report file, I
            usually leave \o off while I perfect my SQL.  With \o off,
            I perfect the SQL query until it produces on my screen exactly
            what I want saved to file.
            At this point I turn on \o and run ":;" to repeat the last SQL
            command.
            If I have several complex queries to run, I turn \o off and
            repeat until I'm finished.
            (Every time you turn \o on, it will append to the file, just
            like we need).
            </p><p>
            Usually it doesn't come to mind that I need a wider screen until
            a query produces lines that are too long.
            In this case, stretch your window and repeat the last command with
            the ":;" Edit Buffer Command.
        </p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="pl-section"></a>SqlTool Procedural Language</h2></div><div><h3 class="subtitle">Aka PL</h3></div></div><div></div></div><p>
            Most importantly, run <tt class="filename">SqlTool</tt> interactively 
            and give the "*?" command to see what PL commands are available to 
            you.
            I've tried to design the language features to be intuitive.
            Readers experience with significant shell scripting in any
            language can probably learn everything they need to know by
            looking at (and running!) the sample script
            <tt class="filename">sample/pl.sql</tt> in your HSQLDB distribution
            <sup>[<a href="#ftn.samplelocFn">1</a>]</sup> and
            using the <tt class="literal">*?</tt> command from within an interactive
            SqlTool session as a reference.  (By
            <span class="emphasis"><em>significant</em></span> shell scripting, I mean to the 
            extent of using variables, for loops, etc.).
        </p><p>
            PL variables will only be expanded after you run a PL command (or 
            set variable(s) from the command-line).
            We only want to turn on variable expansion if the user wants
            variable expansion.
            People who don't use PL don't have to worry about strings getting
            accidentally expanded.
        </p><p>
            All other PL commands imply the "*" command, so you only need to 
            use the "*" statement if your script uses PL variables
            and it is possible that no variables may be set before-hand (and
            no PL commands have been run previously).
            In this case, without "*", your script would silently use a
            literal value like "*{x}" instead of trying to expand it.
            With a preceding "*" command, PL will notice that the variable
            <tt class="literal">x</tt> has not been set and will generate an error.
            (If x had been set here will be no issue because setting a
            variable automatically turns on PL variable expansion).
        </p><p>
            PL is also used to upload and download column values to/from
            local ASCII files, analogously to the special \b commands
            for binary files.
            This is explained above in the Interactive
            <a href="ch08.html#interactive_pl_commands-section" title="PL Commands">Essential PL Command</a>
            section above.
        </p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="N11A15"></a>Variables</h3></div></div><div></div></div><div class="itemizedlist"><ul type="disc"><li>
                    Use the <tt class="literal">* list</tt> command to list some or
                    all variables; or <tt class="literal">* listvalues</tt> to also
                    see the values.
                </li><li>
                    You can set variables using the
                    <tt class="literal">* VARNAME = value</tt> command.
                    This document explains elsewhere how you can set a values
                    to the contents of files, and to the return value of SQL
                    statements and fetches.
                </li><li>
                    You can also set variables using the 
                    <tt class="literal">--setvar</tt> command-line switch.
                    I give a very brief but useful example of this below.
                </li><li>
                    Variables are always expanded in SQL, Special, and PL
                    commands if they are written like
                    <tt class="literal">*{VARNAME}</tt>
                    (assuming that a PL command has been run previously).
                    Your SQL scripts can give good feedback by echoing the
                    value of variables with the "\p" special command.
                    Use the construct <tt class="literal">*{:VARNAME}</tt> to
                    expand the variable, but to expand to a zero-length
                    string instead of fail if VARNAME is not set.
                </li><li><p>
                    A variable written like <tt class="literal">/VARNAME</tt> is
                    expanded if it <span class="emphasis"><em>begins</em></span> an SQL
                    Statement.
                    This usage is called <span class="emphasis"><em>PL Aliasing</em></span>.
                    See the 
                <a href="ch08.html#pl_alias-section" title="PL Aliases">PL Aliases</a>
                    section below.
                </p></li><li>
                    Variables are normally written like 
                    <tt class="literal">*VARNAME</tt> in logical expressions to
                    prevent them from being evaluated too early.
                    See below about logical expressions.
                </li><li><p>
                    You can't do math with expression variables, but you
                    can get functionality like the traditional
                    <tt class="literal">for (i = 0; i &lt; x; i++)</tt> by appending
                    to a variable and testing the string length, like
                    <pre class="programlisting">
    * while (*i &lt; ${x})
        * i = *{i}.</pre>
                    <tt class="literal">i</tt> will be a growing line of dots.
                </p></li><li><p>
                Variable names must not contain white space, or
                the characters "}" or "=".
                </p></li></ul></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="pl_alias-section"></a>PL Aliases</h3></div></div><div></div></div><p>
                PL Aliasing just means the use of a PL variable as the first
                thing in an SQL statement, with the shortcut notation
                <tt class="literal">/VARNAME</tt>.
            </p><p>
                <tt class="literal">/VARNAME</tt> must be followed by whitespace
                or terminate the Statement, in order for SqlFile to tell
                where the variable name ends.
            </p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
                Note that PL aliases are a very different thing from
                SQL aliases or HSQLDB aliases, which are features of
                databases, not SqlFile.
            </p></div><p>
                If the value of a variable is an entire SQL command, you
                generally do not want to include the terminating ";" in
                the value.
                There is an example of this 
                <a href="ch08.html#alias-example" title="Example&nbsp;8.2.&nbsp;Defining and using a PL alias (PL variable)">above</a>.
            </p><p>
            PL aliasing may only be used for SQL statements.
            You can define variables for everything in a Special or PL Command,
            except for the very first character ("\" or "*").
            Therefore, you can use variables other than alias variables in 
            Special and PL Commands.
            Here is a hyperbolically impractical example to show the extent to
            which PL variables can be used in Special commands even though you
            can not use them as PL aliases.
            <pre class="programlisting">
        sql&gt; * qq = p Hello Butch
        sql&gt; \*{qq} done now
        Hello Butch done now</pre>
            (Note that the \* here is not the special command "\*", but is
            the special command "\p" because "*{qq}" resolves to "p").
        </p></div><p>
                Here is a short SQL file that gives the specified user write
                permissions on some application tables.
            </p><div class="example"><a name="N11A89"></a><p class="title"><b>Example&nbsp;8.8.&nbsp;Simple SQL file using PL</b></p><pre class="programlisting">
    /*
       grantwrite.sql

       Run SqlTool like this:
           java -jar path/to/hsqldb.jar -setvar USER=debbie grantwrite.sql
     */

    /* Explicitly turn on PL variable expansion, in case no variables have
       been set yet.  (Only the case if user did not set USER).
    */
    *

    GRANT all ON book TO *{USER};
    GRANT all ON category TO *{USER};</pre></div><p>
                Note that this script will work for any (existing) user just
                by supplying a different user name on the command-line.
                I.e., no need to modify the tested and proven script.
                There is no need for a <tt class="literal">commit</tt> statement
                in this SQL file since no DML is done.
                If the script is accidentally run without setting the
                USER variable, SqlTool will give a very clear notificaton of
                that.
            </p><p>
                The purpose of the plain "*" command is just
                so that the *{USER} variables will be expanded.
                (This would not be necessary if the USER variable, or any
                other variable, were set, but we don't want to depend upon 
                that).
            </p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="N11A97"></a>Logical Expressions</h3></div></div><div></div></div><p>
                Logical expressions occur only inside of logical expression
                parentheses in PL statements.
                For example, <tt class="literal">if (*var1 &gt; astring)</tt> and
                <tt class="literal">while (*checkvar)</tt>.
                (The parentheses after "foreach" do not enclose a logical
                expression, they just enclose a list).
            </p><p>
                There is a critical difference between 
                <tt class="literal">*{VARNAME}</tt> and <tt class="literal">*VARNAME</tt>
                inside logical expressions.
                <tt class="literal">*{VARNAME}</tt> is expanded one time when the
                parser first encounters the logical expression.
                <tt class="literal">*VARNAME</tt> is re-expanded every time that the
                expression is evaluated.
                So, you would never want to code
                <tt class="literal">* while (*{X} &lt; 5)</tt> because the statement
                will always be true or always be false.
                (I.e. the following block will loop infinitely or will never
                run).
            </p><p>
                Don't use quotes or whitespace of any kind in
                <tt class="literal">*{VARNAME}</tt> variables in expressions.
                (They would expand and then the expression would most likely
                no longer be a valid expression as listed in the table below).
                Quotes and whitespace are fine in <tt class="literal">*VARNAME</tt>
                variables, but it is the entire value that will be used in
                evaluations, regardless of whether quotes match up, etc.
                I.e. quotes and whitespace are not <span class="emphasis"><em>special</em></span>
                to the token evaluator.
            </p><div class="variablelist"><p class="title"><b>Logical Operators</b></p><dl><dt><span class="term">TOKEN</span></dt><dd>
                    The token may be a literal, a <tt class="literal">*{VARNAME}</tt>
                    which is expanded early, or a *VARNAME which is expanded 
                    late.
                    (You usually do not want to use 
                    <tt class="literal">*{VARNAME}</tt> in logical expressions).
                    False if the token is not set, empty, or "0".
                    True otherwise.
                </dd><dt><span class="term">TOKEN1 == TOKEN2</span></dt><dd>
                    True if the two tokens are equivalent "strings".
                </dd><dt><span class="term">TOKEN1 &lt;&gt; TOKEN2</span></dt><dd>
                    Ditto.
                </dd><dt><span class="term">TOKEN1 &gt;&lt; TOKEN2</span></dt><dd>
                    Ditto.
                </dd><dt><span class="term">TOKEN1 &gt; TOKEN2</span></dt><dd>
                    True if the TOKEN1 string is longer than TOKEN2 or is
                    the same length but is greater according to a string sort.
                </dd><dt><span class="term">TOKEN1 &lt; TOKEN2</span></dt><dd>
                    Similarly to TOKEN1 &gt; TOKEN2.
                </dd><dt><span class="term">! LOGICAL_EXPRESSION</span></dt><dd>
                    Logical negation of any of the expressions listed above.
                </dd></dl></div><p>
                *VARNAMEs in logical expressions, where the VARNAME variable
                is not set, evaluate to an empty string.
                Therefore <tt class="literal">(*UNSETVAR = 0)</tt> would be false,
                even though <tt class="literal">(*UNSETVAR)</tt> by itself is false
                and <tt class="literal">(0)</tt> by itself is false.
                Another way of saying this is that *VARNAME in a logical 
                expression is equivalent to *{:VARNAME} out of a logical
                expression.
            </p><p>
                When developing scripts, you definitely use SqlTool 
                interactively to verify that SqlTool evaluates logical 
                expressions as you expect.
                Just run <tt class="literal">* if</tt> commands that print something
                (i.e. \p) if the test expression is true.
            </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="N11B10"></a>Flow Control</h3></div></div><div></div></div><p>
                Flow control works by conditionally executing blocks of 
                Commands according to conditions specified by logical 
                expressions.
            </p><p>
                The conditionally executed blocks are called 
                <span class="emphasis"><em>PL Blocks</em></span>.
                These PL Blocks always occur between a PL flow control 
                statement (like <tt class="literal">* foreach, *while, * if</tt>)
                and a corresponding <tt class="literal">* end</tt> PL Command
                (like <tt class="literal">* end foreach</tt>).
            </p><div class="caution" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Caution</h3><p>
                Be aware that the PL block reader is ignorant about SQL 
                statements and comments when looking for the end of the block.
                It just looks for lines beginning with some specific PL commands.
                Therefore, if you put a comment line before a PL statement, 
                or if a line of a multi-line SQL statement has a line beginning
                with a PL command, things may break.
                </p><p>
                I am not saying that you shouldn't use PL commands or SQL
                commands inside of PL blocks-- you definitely should!
                I'm saying that in PL blocks you should not have lines inside 
                of SQL statments or comments which could be mistaken for PL 
                commands.
                (Especially, "commenting out" PL end statements will not work
                if you leave <tt class="literal">* end</tt> at the beginning of the
                line).
                </p><p>
                (This limitation will very likely be removed in a future 
                version of SqlTool).
            </p></div><p>
                The values of control variables for foreach and while PL
                blocks will change as expected.
            </p><p>
                There are <tt class="literal">* break</tt> and 
                <tt class="literal">* continue</tt>, which work as any shell
                scripter would expect them to.
                The <tt class="literal">* break</tt> command can also be used to
                quit the current SQL file without triggering any error 
                processing.
                (I.e. processing will continue with the next line in the 
                <span class="emphasis"><em>including</em></span> SQL file or interactive 
                session, or with the next SQL file if you supplied multiple on 
                the command-line).
            </p></div><p>
            Below is an example SQL File that shows how to use most PL 
            features.  If you have a question about how to use a particular PL 
            feature, check this example before asking for help.
            This file resides in the
            <tt class="filename">sample</tt> directory with the
            name <tt class="filename">pl.sql</tt>
            <sup>[<a href="#ftn.samplelocFn">1</a>]</sup>.
            Definitely give it a run, like <pre class="screen">
java -jar $HSQLDB_HOME/lib/hsqldb.jar mem $HSQLDB_HOME/pl.jar</pre>
        </p><div class="example"><a name="N11B55"></a><p class="title"><b>Example&nbsp;8.9.&nbsp;SQL File showing use of most PL features</b></p><pre class="programlisting">/*
    $Id: pl.sql,v 1.3 2004/06/10 01:44:52 unsaved Exp $
    SQL File to illustrate the use of SqlTool PL features.
    Invoke like
        java -jar .../hsqldb.jar .../pl.sql mem
                                                         -- blaine
*/

* if (! *MYTABLE)
    \p MYTABLE variable not set!
    /* You could use \q to Quit SqlTool, but it's often better to just
       break out of the current SQL file.
       If people invoke your script from SqlTool interactively (with
       \i yourscriptname.sql) any \q will kill their SqlTool session. */
    \p Use arguments "--setvar MYTABLE=mytablename" for SqlTool
    * break
* end if

/* Turning on Continue-upon-errors so that we can check for errors ourselves.*/
\c true

\p
\p Loading up a table named '*{MYTABLE}'...

/* This sets the PL variable 'retval' to the return status of the following
   SQL command */
* retval ~
CREATE TABLE *{MYTABLE} (
    i int,
    s varchar
);
\p CREATE status is *{retval}
\p

/* Validate our return status.  In logical expressions, unset variables like
   *unsetvar are equivalent to empty string, which is not equal to 0
   (though both do evaluate to false on their own, i.e. (*retval) is false
   and (0) is false */
* if (*retval != 0)
    \p Our CREATE TABLE command failed.
    * break
* end if

/* Default Continue-on-error behavior is what you usually want */
\c false
\p

/* Insert data with a foreach loop.
   These values could be from a read of another table or from variables
   set on the command line like
*/
\p Inserting some data int our new table (you should see 3 row update messages)
* foreach VALUE (12 22 24 15)
    * if (*VALUE &gt; 23)
        \p Skipping *{VALUE} because it is greater than 23
        * continue
        \p YOU WILL NEVER SEE THIS LINE, because we just 'continued'.
    * end if
    INSERT INTO *{MYTABLE} VALUES (*{VALUE}, 'String of *{VALUE}');
* end foreach
\p

* themax ~
/* Can put Special Commands and comments between "* VARNAME ~" and the target 
   SQL statement. */
\p We're saving the max value for later.  You'll still see query output here:
SELECT MAX(i) FROM *{MYTABLE};

/* This is usually unnecessary because if the SELECT failed, retval would
   be undefined and the following print statement would make SqlTool exit with
   a failure status */
* if (! *themax)
    \p Failed to get the max value.
    /* It's possible that the query succeeded but themax is "0".
       You can check for that if you need to. */
    * break
    \p YOU WILL NEVER SEE THIS LINE, because we just 'broke'.
* end if

\p
\p ##############################################################
\p The results of our work:
SELECT * FROM *{MYTABLE};
\p MAX value is *{themax}

\p
\p Everything worked.
</pre></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="chunk-section"></a>Chunking</h2></div></div><div></div></div><p>
            We hereby call the ability to transmit multiple SQL commands to
            the database in one transmission <span class="emphasis"><em>chunking</em></span>.
            Unless you are in Raw mode, SqlTool only transmits commands to the
            database engine when it reads in a ";" at the end of a line of an
            SQL command.
            Therefore, you normally want to end each and every SQL command 
            with ";" at the end of a line.
            This is because the database can only send one status reply to
            each JDBC transmission.
            So, while you could run
        <div class="informalexample"><pre class="screen">
    SELECT * FROM t1; SELECT * FROM t2;</pre></div>
            SqlTool can only display the results from the last query.
            This is a limitation of the client/server nature of JDBC, and
            applies to any JDBC client.
            There are, however, situations where you don't need immediate
            feedback from every SQL command.  For example,
        <div class="example"><a name="N11B6A"></a><p class="title"><b>Example&nbsp;8.10.&nbsp;Single-line chunking example</b></p><pre class="screen">
    INSERT INTO t1 VALUES(0); SELECT * FROM t1;</pre></div>
            It's useful because the output of the second SQL command will tell
            you whether the first SQL command succeeded.  So, you won't miss
            the status output from the first command.
        </p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="N11B71"></a>Why?</h3></div></div><div></div></div><p>
                The first general reason to chunk SQL commands is performance.
                For standalone databases, the most common performance 
                bottleneck is network latency.
                Chunking SQL commands can dramatically reduce network traffic.
            </p><p>
                The second general reason to chunk SQL commands is if your
                database requires you to send multiple commands in one
                transmission.
                This is often the case when you need to tell the database
                the SQL or PL/SQL commands that comprise a stored procedure,
                function, trigger, etc.
            </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="N11B78"></a>How?</h3></div></div><div></div></div><p>
                The most simple way is enter as many SQL commands as you 
                want, but just do not end a line with ";" until you want
                the chunk to transmit.
                <div class="example"><a name="N11B7D"></a><p class="title"><b>Example&nbsp;8.11.&nbsp;Multi-line chunking example</b></p><pre class="screen">
    INSERT INTO t1 VALUES (1)
    ; INSERT INTO t1 VALUES (2)
    ; SELECT * FROM t1;</pre></div>
                If you list your command history with \s, you will see that
                all 3 SQL commands in 3 lines are in one SqlTool command.
                You can recall this SqlTool command from history to
                re-execute all three SQL commands.
            </p><p>
                The other method is by using 
                <a href="ch08.html#raw-section" title="Raw Mode">Raw Mode</a>.
                Go to the
                <a href="ch08.html#raw-section" title="Raw Mode">Raw Mode</a> section
                to see how.
                You can enter any text at all, exactly how you want it to
                be sent to the database engine.
                Therefore, in addition to chunking SQL commands, you can
                give commands for non-SQL extensions to the database.
                For example, you could enter JavaScript code to be used
                in a stored procedure.
            </p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="raw-section"></a>Raw Mode</h2></div></div><div></div></div><p>
            You begin raw mode by issuing the Special Command "\.".
            You can then enter as much text in any format you want.
            When you are finished, enter a line consisting of only ".;"
            to store the input to the edit buffer and send it to the
            database server for execution.
        </p><p>
            This paragraph applies only to interactive usage.
            Interactive users may may end the raw input with ":." 
            instead of ".;".
            This will just save the input to the edit buffer so that you can 
            edit it and send it to the database manually.
            You can look at the edit buffer with the ":b" Buffer Command.
            You would normally use the command ":;" to
            send the buffer to the database after you are satisfied with it.
            You'll notice that your prompt will be the continuation prompt 
            between entering "\." and terminating the raw input with ".;" 
            or ":.".
        </p><p>
            <div class="example"><a name="N11B99"></a><p class="title"><b>Example&nbsp;8.12.&nbsp;Interactive Raw Mode example</b></p><pre class="screen">
    sql&gt; \.
    Enter RAW SQL.  No \, :, * commands.
    End with a line containing only ".;" to send to database,
    or ":." to store to edit buffer for editing or saving.
    -----------------------------------------------------------
    raw&gt; line one;
      +&gt; line two;
      +&gt; line three;
      +&gt; :.
    Raw SQL chunk moved into buffer.  Run ":;" to execute the chunk.
    sql&gt; :;
    Executing command from buffer:
    line one;
    line two;
    line three;

    SQL Error at 'stdin' line 13:
    "line one;
    line two;
    line three;"
    Unexpected token: LINE in statement [line]
    sql&gt;</pre></div>
            The error message "Unexpected token: LINE in statement [line]"
            comes from the database engine, not SqlTool.
            All three lines were transmitted to the database engine.
        </p><p>
            Edit Buffer Commands are not available when running SqlTool
            non-interactively.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="N11BA2"></a>PL/SQL</h2></div></div><div></div></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
            PL/SQL is <span class="bold"><b>not</b></span> the same as
            PL.  PL is the procedural language of SqlFile and is 
            independent of your back-end database.
            PL commands always begin with *.
            PL/SQL is processed on the server side and you can only use
            it of your database supports it.
            You can not intermix PL and PL/SQL (except for setting a
            PL variable to the output of PL/SQL execution), because when
            you enter PL/SQL to SqlTool that input is not processed
            by SqlFile.
        </p></div><p>
            Use <a href="ch08.html#raw-section" title="Raw Mode">Raw Mode</a> to send
            PL/SQL code blocks to the database engine.
            You do not need to enter the "\." command to enter raw mode.
            Just begin a new SqlTool command line with "DECLARE" or 
            "BEGIN", and SqlTool will automatically put you into raw mode.
            See the <a href="ch08.html#raw-section" title="Raw Mode">Raw Mode</a>
            section for details.
        </p><p>
            The following sample SQL file resides at 
            <tt class="filename">sample/plsql.sql</tt> in your HSQLDB distribution
            <sup>[<a href="#ftn.samplelocFn">1</a>]</sup>.
            This script will only work if your database engine supports
            standard PL/SQL, if you have permission to create the table
            "T1" in the default schema, and if that object does not 
            already exist.
            <div class="example"><a name="N11BBF"></a><p class="title"><b>Example&nbsp;8.13.&nbsp;PL/SQL Example</b></p><pre class="programlisting">/*
 * $Id: plsql.sql 228 2007-06-12 02:26:40Z unsaved $
 *
 * This example is copied from the "Simple Programs in PL/SQL"
 * example by Yu-May Chang, Jeff Ullman, Prof. Jennifer Widom at
 * the Standord University Database Group's page
 * http://www-db.stanford.edu/~ullman/fcdb/oracle/or-plsql.html .
 * I have only removed some blank lines (in case somebody wants to
 * copy this code interactively-- because you can't use blank
 * lines inside of SQL commands in non-raw mode SqlTool when running
 * it interactively); and, at the bottom I have  replaced the
 * client-specific, non-standard command "run;" with SqlTool's
 * corresponding command ".;" and added a plain SQL SELECT command
 * to show whether the PL/SQL code worked.  - Blaine
 */

CREATE TABLE T1(
    e INTEGER,
    f INTEGER
);

DELETE FROM T1;

INSERT INTO T1 VALUES(1, 3);

INSERT INTO T1 VALUES(2, 4);

/* Above is plain SQL; below is the PL/SQL program. */
DECLARE

    a NUMBER;

    b NUMBER;

BEGIN

    SELECT e,f INTO a,b FROM T1 WHERE e&gt;1;

    INSERT INTO T1 VALUES(b,a);

END;

.;
/** The statement on the previous line, ".;" is SqlTool specific.
 *  This command says to save the input up to this point to the
 *  edit buffer and send it to the database server for execution.
 *  I added the SELECT statement below to give imm
 */

/* This should show 3 rows, one containing values 4 and 2 (in this order)...*/
SELECT * FROM t1;
</pre></div>
            Note that, inside of raw mode, you can use any kind of formatting
            you want:  Whatever you enter--  blank lines, comments,
            everything-- will be transmitted to the database engine.
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="altjar-section"></a>Using hsqltool.jar and hsqldbutil.jar</h2></div></div><div></div></div><p>
            This section is for those users who want to use SqlTool but 
            without the overhead of hsqldb.jar (or who want to use a new
            SqlTool build with an older HSQLDB distribution).
        </p><p>
            If you do not need to directly use JDBC URLs like
            <tt class="literal">jdbc:hsqldb:mem:</tt> + something,
            <tt class="literal">jdbc:hsqldb:file:</tt> + something, or
            <tt class="literal">jdbc:hsqldb:res:</tt> + something,
            then you can use <tt class="filename">hsqltool.jar</tt> in place of
            the much larger <tt class="filename">hsqldb.jar</tt> file.
            <tt class="filename">hsqltool.jar</tt> will work for all JDBC
            databases other than HSQLDB Memory-only and In-process databases
            (the latter are fine if you access them via a HSQLB Server or
            WebServer).
            You will have to supply the JDBC driver for non-HSQLDB URLs, of
            course.
        </p><p>
            <tt class="filename">hsqltool.jar</tt> includes the HSQLDB JDBC
            driver.
            If you do not need to connect to HSQLDB databases at all, 
            then <tt class="filename">hsqldbutil.jar</tt> is what you want.
            <tt class="filename">hsqldbutil.jar</tt> contains everything you
            need to run <tt class="filename">SqlTool</tt> and
            <tt class="filename">DatabaseManagerSwing</tt> against non-HSQLDB
            databases... well, besides the JDBC drivers for the target
            databases.
        </p><p>
            The HSQLDB distribution doesn't "come with" pre-built 
            <tt class="filename">hsqltool.jar</tt> and
            <tt class="filename">hsqldbutil.jar</tt> files.
            You need to "build" them, but that is very easy to do.
        </p><p>
            These instructions assume that you are capable of running an Ant
            build. 
            See the
            <a href="apa.html" title="Appendix&nbsp;A.&nbsp;Building HSQLDB">Building HSQLDB</a>
            chapter if you need more details than what you see here.
        </p><div class="procedure"><ol type="1"><li><p>
                Download and extract a current HSQLDB distribution.
                If you don't want to use the source code, documentation,
                etc., you can use a temporary directory and remove it
                afterwards.
            </p></li><li><p>
                Cd to the build directory under the root directory where
                you extracted the distribution to.
            </p></li><li><p>
                Run <tt class="literal">ant hsqldbutil</tt> or
                <tt class="literal">ant hsqltool</tt> according to the criteria
                above.
                (If your goal is to use this jar with an older HSQLDB
                distribution, then you definitely need to build
                <tt class="filename">hsqlbutil.jar</tt>).
            </p></li><li><p>
                If you're going to clean up afterwards, copy the
                jar that you built out of <tt class="filename">lib</tt>
                to a safe location first.
            </p></li></ol></div><p>
            If you are using the HSQLDB JDBC driver (i.e., you're connecting
            up to a URL like jdbc:hsqldb:hsql + something or
            jdbc:hsqldb:http + something), you invoke SqlTool exactly as with
            hsqldb.jar except you use the file path to your new jar file
            instead of the path to <tt class="filename">hsqldb.jar</tt>.
        </p><p>
            If you are using a non-HSQLDB JDBC driver, you must set your
            CLASSPATH to include this new jar file and your JDBC driver,
            then run SqlTool like <div class="informalexample"><pre class="screen">
        java org.hsqldb.util.SqlTool ...</pre></div>
            You can specify your JDBC driver class either with the
            <tt class="literal">--driver</tt> switch to SqlTool, or in your
            RC file stanza (the last method is usually more convenient).
        </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="N11C3F"></a>Delimiter-Separated-Value Imports and Exports</h2></div></div><div></div></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Note</h3><p>
            This feature is independent of HSQLDB 
            <a href="ch06.html" title="Chapter&nbsp;6.&nbsp;Text Tables">Text Tables</a>,
            a server-side feature of HSQLDB.
            It makes no difference to SqlTool whether the source or target
            table of your export/import is a memory, cache, or text table.
            Indeed, like all features of SqlTool, it works fine with other
            JDBC databases.
            It works great, for example to migrate data from a table
            of one type to a table of another type, or to another schema,
            or to another database instance, or to another database system.
        </p></div><p>
            This feature is what most business people call "CSV", but
            these files are more accurately called <span class="emphasis"><em>Delimiter 
            Separated Value files</em></span> because the delimiter is
            usually not a comma, and, more importantly, we purposefully
            choose an effective delimiter instead of the CSV method of
            using a delimiter which works in some cases and then use
            quotes and back-slashes to escape occurrence of the delimiter
            in the actual data.
            Just by choosing a delimiter which never needs escaping, we
            eliminate the whole mess, and the data in our files always
            looks just like the corresponding data in the database.
            To make this CSV / Delimiter-separated-value dintinction clear,
            I use the suffix ".dsv" for my data files.
            This leads me to stipulate the abbreviation DSV for the
            <span class="emphasis"><em>Delimiter Separated Value</em></span> feature of
            HSQLDB.
        </p><p>
            Use the <tt class="literal">\x</tt> command to eXport a table to a
            DSV file, and the <tt class="literal">\m</tt> command to iMport a
            DSV file into a pre-existing table.
        </p><p>
            The row and column delimiters may be any String, not just a
            single character.
            And just as the delimiter capability is more general than 
            traditional CSV delimiters, the export function is also more 
            general than just a table data exporter.
            Besides the trivial generalization that you may specify a
            view or other virtual table name in place of a table name,
            you can alternatively export the output of any query which 
            produces normal text output.
            A benefit to this approach is that it allows you to export only
            some columns of a table, and to specify a WHERE clause to narrow 
            down the rows to be exported (or perform any other SQL 
            transformation, mapping, join, etc.).
            One specific use for this would be to exclude columns of
            binary data (which can be exported by other means, such as
            a PL loop to store binary values to files with the \bd command).
        </p><p>
            Note that the import command will not create a new table.
            This is because of the impossibility of guessing appropriate
            types and constraints based only on column names and a data
            sampling (which is all that a DSV-importer has access to).
            Therefore, if you wish to populate a new table, create the
            table before running the import.
            The import file does not need to have data for all columns of a
            table.
            The only required columns are those required by database
            constraints (non-null, indexes, keys, etc.)
            One specific reason to omit columns is if you want values of
            some columns to be created automatically by column DEFAULT
            settings, triggers, HSQLDB identity sequences, etc.
            Another reason would be to skip binary columns.
        </p><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="N11C5F"></a>Simple DSV exports and imports using default settings</h3></div></div><div></div></div><p>
                Even if you need to change delimiters, table names, or file
                names from the defaults, I suggest that you run one export
                and import with default settings as a practice run.
                A memory-only HSQLDB instance is ideal for test runs like this.
            </p><p>
                This command exports the table <tt class="literal">icf.projects</tt>
                to the file <tt class="filename">projects.dsv</tt> in the current
                directory (where you invoked SqlTool from).
                By default, the output file name will be the specified source
                table name plus the extension <tt class="literal">.dsv</tt>.
                <div class="example"><a name="N11C72"></a><p class="title"><b>Example&nbsp;8.14.&nbsp;DSV Export Example</b></p><pre class="screen">    SET SCHEMA icf;
    \x projects
</pre></div>
                We could also have run <tt class="literal">\x icf.projects</tt>
                (which would have created a file named 
                <tt class="filename">icf.projects.dsv</tt>)
                instead of changing the session schema.
                In this example we have chosen to make the export file name
                independent of the schema to facilitate importing it into
                a different schema.
            </p><p>
                Take a look at the output file.
                Notice that the first line consists of column names, not
                data.
                This line is present because it will be needed if the file is
                to used for a DSV import.
                Notice the following characterstics about the export data.
                The column delimiter is the pipe character "|".
                The record delimiter is the default line delimiter character(s)
                for your operating system.
                The string used to represent database <tt class="literal">NULL</tt>s
                is <tt class="literal">[null]</tt>.
                See the next section for how to change these from their default
                values.
            </p><p>
                This command imports the data from the file
                <tt class="filename">projects.dsv</tt> in the current
                directory (where you invoked SqlTool from) into the table
                <tt class="literal">newschema.projects</tt>.
                By default, the output table name will be the input filename
                after removing optional leading directory and trailing final
                extension.
                <div class="example"><a name="N11C95"></a><p class="title"><b>Example&nbsp;8.15.&nbsp;DSV Import Example</b></p><pre class="screen">    SET SCHEMA newschema;
    \m projects.dsv
</pre></div>
                If the DSV file was named with the target schema, you would
                have skipped the <tt class="literal">SET SCHEMA</tt> command, like
                <tt class="literal">\m newschema.projects.dsv</tt>.
            </p></div><div class="section" lang="en"><div class="titlepage"><div><div><h3 class="title"><a name="N11CA4"></a>Specifying queries and options</h3></div></div><div></div></div><p>
                For a hands on example of a DSM import which generates
                an import report and uses some other options, change to
                directory <tt class="filename">HSQLDB/sample</tt> and play
                with the working script <tt class="filename">dsv-sample.sql</tt>
                <sup>[<a href="#ftn.samplelocFn">1</a>]</sup>.
                You can execute it like
                <div class="informalexample"><pre class="screen">
    java -jar ../lib/hsqldb.jar mem dsv-sample.sql</pre></div>
                (assuming that you are using the supplied
                <tt class="filename">sqltool.rc</tt> file or have have urlid
                <tt class="literal">mem</tt> set up.
            </p><p>
                The header line in the DSV file is required at this time.
                (If there is user demand, it can be made optional for
                exporting, but it will remain required for importing).
            </p><p>
                Your export will fail if the column or record delimiter, or
                the null representation value occurs in the data being
                exported.
                You change these values by setting the PL variables
                <tt class="literal">*DSV_COL_DELIM</tt>,
                <tt class="literal">*DSV_ROW_DELIM</tt>,
                <tt class="literal">*DSV_NULL_REP</tt>.
                Notice that the asterisk is part of the variable names, to
                indicate that these variables are used by SqlTool internally.
                When specifying delimiters, you can use the escape seqpences
                \n, \r, \f, \t, \\, and decimal, octal or hex specifications 
                like \20, \020, \0x20.
                For example, to change the column delimiter to the tab character,
                you would give the command
                <div class="informalexample"><pre class="screen">
    * *DSV_COL_DELIM = \t</pre></div>
            </p><p>
                For imports, you must always specify the source DSV file path.
                If you want to <span class="emphasis"><em>export</em></span> to a different file 
                than one in the current directory named according to the source
                table, set the PL variable <tt class="literal">*DSV_TARGET_FILE</tt>,
                like
                <div class="informalexample"><pre class="screen">
    * *DSV_TARGET_FILE = /tmp/dtbl.dsv</pre></div>
            </p><p>
                For exports, you must always specify the source table name
                or query.
                If you want to <span class="emphasis"><em>import</em></span> to a table other 
                than that derived from
                the input DSV file name, set the PL variable
                <tt class="literal">*DSV_TARGET_TABLE</tt>.
                The table name may contain a schema name prefix.
            </p><p>
                You don't need to import all of the columns in a data file.
                To designate the fields to be skipped, iether set the PL
                PL variable <tt class="literal">*DSV_SKIP_COLUMNS</tt>, or replace
                the column names in the header line to "-" (hyphen).
                The value of <tt class="literal">*DSV_SKIP_COLUMNS</tt> is 
                case-insensitive, and multiple column names are separated with
                white space and/or commas.
            </p><p>
                You can specify a query instead of a tablename with the
                \x command in order to filter or transform data from a table
                or view, or to export the output of a join, etc.
                You must set the PL variable <tt class="literal">*DSV_TARGET_FILE</tt>,
                as explained above (since there is no table name from which to
                automatically map a file name).
                <div class="example"><a name="N11CFD"></a><p class="title"><b>Example&nbsp;8.16.&nbsp;DSV Export of an Arbitrary SELECT Statement</b></p><pre class="screen">    * *DSV_TARGET_FILE = outfile.txt
    \x SELECT entrydate, 2 * aval "Double aval", modtime FROM bs.dtbl</pre></div>
                Note that I specified the column label alias "Double aval"
                so that the label for that column in the DSV file header will 
                not be blank.
            </p><p>
                By default, imports will abort as soon as a error is 
                encountered during parsing the file or inserting data.
                If you invoke SqlTool with a SQL script on the command line,
                the failure will cause SqlTool to roll back and exit.
                If run interactively, you can decide whether to commit or
                roll back the rows that inserted before the failure.
                You can modify this behavior with the \a and \c settings.
            </p><p>
                If you set either a reject dsv file or a reject report file,
                then failures during imports will be reported but will not
                cause the import to abort.
                When run in this way, SqlTool will give you a report at
                the end about how many records were skipped, rejected, and
                successfully inserted.
                The reject dsv file is just a dsv file with exact copies of
                the dsv records that failed to insert.
                The reject report file is a HTML report which lists, for
                every rejected record, why that record was rejected.
            </p><p>
                To allow for user-friendly entry of headers, we require
                that tables for DSV import/exports use standard column names.
                I.e., no column names that require quoting.
                The DSV import and export parsers are very smart and
                user-friendly.
                The data types of columns are checked so that the parser can
                make safe assumptions about white space and blank entries in
                the data.
                If a column is a JDBC Boolean type, for example, then we
                know that a field value of "  True " obviously means "True",
                and that a field value of "" obviously means null.
                Since we require vanilla style column names, we allow
                white space anywhere in the header column.
                We allow blank lines anywhere (where "lines" are delimited
                by *DSV_ROW_DELIM).
                By default, commented lines are ignored, and the comment
                character can be changed from its default value.
            </p><p>
                Run the command "\x?" or "\m?" to see the several system PL 
                variables which you can set to adjust reject file behavior,
                commenting behavior, and other DSV features.
            </p><p>
                You can also define some settings right in the DSV file,
                and you can even specify multiple header lines in a single
                DSV file.
                I use this last feature to import data from one data set
                into multple tables that are joined.
                Since I don't have any more time to dedicate to explaining
                all of these features, I'll give you some examples from 
                working DSV files and let you take it from there.
        <div class="example"><a name="N11D0E"></a><p class="title"><b>Example&nbsp;8.17.&nbsp;Sample DSV headerswitch settings</b></p><pre class="programlisting">
    # RCS keyword was here.

    headerswitch{
    itemdef:name|-|-|hardness|breakdc|-
    simpleitemdef:itemdef_name|maxvalue|weight|-|-|maxhp
    }</pre></div>
            I'll just note that the prefixes for the header rows must be of
            format target-table-name + :.
            You can use * for target-table-name here, for the obvious purpose.
        <div class="example"><a name="N11D15"></a><p class="title"><b>Example&nbsp;8.18.&nbsp;DSV targettable setting</b></p><pre class="programlisting">
    targettable=t</pre></div>
                This last example is from the SqlTool unit test file 
                <tt class="filename">dsv-trimming.dsv</tt>.
                These special commands must be at the top of the file
                (before any normal data or header lines).
            </p><p>
                There is also the <tt class="literal">*DSV_CONST_COLS</tt> setting,
                which you can use to automatically write static, constant
                values to the specified columns of all inserted rows.
            </p></div></div><div class="section" lang="en"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="N11D26"></a>Unit Testing SqlTool</h2></div></div><div></div></div><p>
          The SqlTool unit tests reside at testrun/sqltool in the
          HSQLDB source code repository.
          Just run the <tt class="filename">runtests.bash</tt> script from
          that directory to execute all of the tests.
          Read the file <tt class="filename">README.txt</tt> to find out all
          about it, including everything you'd need to know to test your
          own scripts or to add more unit test scripts for SqlTool.
        </p></div><div class="footnotes"><br><hr align="left" width="100"><div class="footnote"><p><sup>[<a href="#samplelocFn" name="ftn.samplelocFn">1</a>] </sup>
            To reduce the time I will need to spend maintaining this document,
            in this chapter I am giving the path to the
            <tt class="filename">sample</tt> directory as it is in HSQLDB 1.9.x
            distributions, namely, <tt class="filename">HSQLDB_HOME/sample</tt>.
            HSQLDB 1.8.x users should translate these sample directory paths
            to use <tt class="filename">HSQLDB_HOME/src/org/hsqldb/sample/...</tt>.
            </p></div></div></div><div class="navfooter"><hr><table summary="Navigation footer" width="100%"><tr><td align="left" width="40%"><a accesskey="p" href="ch07.html"><img src="navicons/prev.gif" alt="Prev"></a>&nbsp;</td><td align="center" width="20%"><a accesskey="u" href="index.html"><img src="navicons/up.gif" alt="Up"></a></td><td align="right" width="40%">&nbsp;<a accesskey="n" href="ch09.html"><img src="navicons/next.gif" alt="Next"></a></td></tr><tr><td valign="top" align="left" width="40%">Chapter&nbsp;7.&nbsp;TLS&nbsp;</td><td align="center" width="20%"><a accesskey="h" href="index.html"><img src="navicons/home.gif" alt="Home"></a></td><td valign="top" align="right" width="40%">&nbsp;Chapter&nbsp;9.&nbsp;SQL Syntax</td></tr></table></div></body></html>