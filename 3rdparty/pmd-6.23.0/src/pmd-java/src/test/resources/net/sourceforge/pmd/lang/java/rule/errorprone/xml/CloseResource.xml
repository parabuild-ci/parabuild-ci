<?xml version="1.0" encoding="UTF-8"?>
<test-data
    xmlns="http://pmd.sourceforge.net/rule-tests"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://pmd.sourceforge.net/rule-tests http://pmd.sourceforge.net/rule-tests_1_0_0.xsd">
    <test-code>
        <description>connection is closed, ok</description>
        <rule-property name="types">java.sql.Connection,java.sql.Statement,java.sql.ResultSet</rule-property>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
import java.sql.Connection;

public class Foo {
 void bar() {
  Connection c = pool.getConnection();
  try {
  } catch (Exception e) {
  } finally {
   c.close();
  }
 }
}
     ]]></code>
    </test-code>

    <test-code>
        <description>connection not closed, should have failed</description>
        <rule-property name="types">java.sql.Connection,java.sql.Statement,java.sql.ResultSet</rule-property>
        <expected-problems>1</expected-problems>
        <expected-linenumbers>4</expected-linenumbers>
        <expected-messages>
            <message>Ensure that resources like this Connection object are closed after use</message>
        </expected-messages>
        <code><![CDATA[
import java.sql.*;
public class Foo {
 void bar() {
  Connection c = pool.getConnection();
  try {
  } catch (Exception e) {
  }
 }
}
     ]]></code>
    </test-code>
    <test-code>
        <description>ResultSet not closed, should have failed</description>
        <rule-property name="types">java.sql.Connection,java.sql.Statement,java.sql.ResultSet</rule-property>
        <expected-problems>1</expected-problems>
        <code><![CDATA[
import java.sql.*;
public class Foo {
 void bar() {
  ResultSet c = pool.getRS();
  try {
  } catch (Exception e) {}
 }
}
     ]]></code>
    </test-code>
    <test-code>
        <description>Statement not closed, should have failed</description>
        <rule-property name="types">java.sql.Connection,java.sql.Statement,java.sql.ResultSet</rule-property>
        <expected-problems>1</expected-problems>
        <code><![CDATA[
import java.sql.*;
public class Foo {
 void bar() {
  Statement c = pool.getStmt();
  try {
  } catch (Exception e) {}
 }
}
     ]]></code>
    </test-code>
    <code-fragment id="executeQuery"><![CDATA[
import java.sql.*;
public class Foo {
 void bar() {
  Statement c = pool.getStmt();
  Statement st = c.executeQuery("SELECT * FROM FOO");
  try {
  } finally {
     MyHelper.close(c);
     cleanup(st);
}
 }
}
     ]]></code-fragment>
    <test-code>
        <description>Bad, no closeTargets properties for statements</description>
        <rule-property name="types">java.sql.Connection,java.sql.Statement,java.sql.ResultSet</rule-property>
        <expected-problems>2</expected-problems>
        <code-ref id="executeQuery"/>
    </test-code>
    <test-code>
        <description>Ok, closeTargets properties for statements</description>
        <rule-property name="closeTargets">MyHelper.close,cleanup</rule-property>
        <rule-property name="types">java.sql.Connection,java.sql.Statement,java.sql.ResultSet</rule-property>
        <expected-problems>0</expected-problems>
        <code-ref id="executeQuery"/>
    </test-code>

    <test-code>
        <description>Add type param</description>
        <rule-property name="types">java.io.ObjectInputStream</rule-property>
        <expected-problems>1</expected-problems>
        <code><![CDATA[
import java.io.*;
public class BadClose {
private void readData() {
File aFile = new File(FileName);
FileInputStream anInput = new FileInputStream(aFile);
ObjectInputStream aStream = new ObjectInputStream(anInput);

readExternal(aStream);
}
}
     ]]></code>
    </test-code>

    <test-code>
        <description>OK with custom closeTargets</description>
        <rule-property name="closeTargets">MyHelper.close</rule-property>
        <rule-property name="types">java.sql.Connection,java.sql.Statement,java.sql.ResultSet</rule-property>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
import java.sql.*;
public class Foo {
 void bar() {
  Statement c = pool.getStmt();
  try {
  } finally {
     MyHelper.close(c);
}
 }
}
     ]]></code>
    </test-code>
    <test-code>
        <description>New use case: commit</description>
        <rule-property name="closeTargets">commit,close</rule-property>
        <rule-property name="types">DAOTransaction,java.sql.Connection,java.sql.Statement,java.sql.ResultSet</rule-property>
        <expected-problems>1</expected-problems>
        <expected-linenumbers>8</expected-linenumbers>
        <code><![CDATA[
import java.sql.*;
public class Foo {
	public void bar() throws SQLException
	{
		DAOTransaction trx = trxManager.open();
		Connection cnx = pool.newConn();
		ResultSet rs = null;
		Statement stmt = null;

		try
		{
			// ...
		}
		finally
		{
			//stmt.close(); // Error !!! you have to close the Statement
			rs.close(); // Correct
			cnx.commit(); // Correct ( cnx.close() would be equivalent)
			trx.commit(); // Correct
		}
	}
}
     ]]></code>
    </test-code>

    <test-code>
        <description>[1964798] 3 bugs in CloseResourceRule : Case failing with complete name</description>
        <rule-property name="closeTargets">MyHelper.MyClose</rule-property>
        <rule-property name="types">java.sql.Connection,java.sql.Statement,java.sql.ResultSet</rule-property>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
import java.sql.*;
public class Foo {
 void bar() {
  Statement c = pool.getStmt();
  try {
  } finally {
     MyHelper.MyClose(c);
}
 }
}
     ]]></code>
    </test-code>

    <test-code>
        <description>[1964798] 3 bugs in CloseResourceRule : null object is passed to close conection method (1)</description>
        <rule-property name="closeTargets">this.closeConnection</rule-property>
        <rule-property name="types">java.sql.Connection,java.sql.Statement,java.sql.ResultSet</rule-property>
        <expected-problems>1</expected-problems>
        <code><![CDATA[
import java.sql.*;
public class Foo {
 void bar() {
  Connection c;
  try {
    c = pool.getConnection();
  } finally {
     this.closeConnection(null);
  }
 }
}
     ]]></code>
    </test-code>
   <test-code>
        <description>[1964798] 3 bugs in CloseResourceRule : null object is passed to close conection method (2)</description>
        <rule-property name="closeTargets">this.closeConnection</rule-property>
        <rule-property name="types">java.sql.Connection,java.sql.Statement,java.sql.ResultSet</rule-property>
        <expected-problems>1</expected-problems>
        <code><![CDATA[
import java.sql.*;
public class Foo {
 void bar() {
  Connection c = pool.getConnection();
  try {
    //...
  } finally {
     this.closeConnection(null);
  }
 }
}
     ]]></code>
    </test-code>
    <test-code>
        <description>[1964798] 3 bugs in CloseResourceRule : If connection is returned, we should not log a violation.</description>
        <rule-property name="types">Connection,Statement,ResultSet</rule-property>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
public class Foo {
	public Connection getConnection() {
		Connection c = pool.getConnection();
		return c;
	}
}
     ]]></code>
    </test-code>
    <test-code reinitializeRule="true">
        <description>invoke an external method that close the resource: bug 2920057</description>
        <rule-property name="closeTargets">closeStatement,closeStatement,closeResultSet,closeConnexion</rule-property>
        <rule-property name="types">java.sql.Connection,java.sql.Statement,java.sql.ResultSet,java.sql.PreparedStatement</rule-property>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
import java.sql.*;

public class StructureFactory {

    public void rechercherListe() {

        Connection _connexion = null;
        ResultSet _rs = null;
        PreparedStatement _st = null;
        try
        {
           //
        }


        finally
        {
            getProviderInstance().closeConnexion(_connexion);
            getProviderInstance().closeResultSet(_rs);
            getProviderInstance().closeStatement(_st);
            
        }
    }
}
     ]]></code>
    </test-code>
    <test-code reinitializeRule="true">
        <description>invoke an external method that closes the resource, but one is not the right method and an another is not the right variable: see bug 2920057</description>
        <rule-property name="closeTargets">closeStatement,closeStatement,closeResultSet,closeConnexion</rule-property>
        <rule-property name="types">java.sql.Connection,java.sql.Statement,java.sql.ResultSet,java.sql.PreparedStatement</rule-property>
        <expected-problems>2</expected-problems>
        <code><![CDATA[
import java.sql.*;

public class StructureFactory {

    public void searchList() {

        Connection _connexion = pool.getConn();
        ResultSet _rs = createResultSet(_connexion);
        PreparedStatement _st = createPrepStmt(_connexion);
        Structure _structure = null;
        try
        {
           //
        }


        finally
        {
            getProviderInstance().closeConnexion(_connexion);
            getProviderInstance().closeYourEyes(_rs); //not the right method
            getProviderInstance().closeStatement(_badOne); // not the right variable
            
        }
    }
}
     ]]></code>
    </test-code>
    <test-code reinitializeRule="true">
        <description>#1011 CloseResource Rule ignores Constructors</description>
        <expected-problems>1</expected-problems>
        <code><![CDATA[
import java.sql.Connection;

public class Test {
    public Test() {
        Connection c = pool.getConnection();
    }
}
        ]]></code>
    </test-code>
    <test-code reinitializeRule="true">
        <description>#1011 CloseResource Rule ignores Constructors - closed in finally</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
import java.sql.Connection;

public class Test {
    public Test() {
        Connection c;
        try {
            c = pool.getConnection();
        } finally {
            c.close();
        }
    }
}
        ]]></code>
    </test-code>
    <test-code reinitializeRule="true">
        <description>#1011 CloseResource Rule ignores Constructors - not a problem - instance variable</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
import java.sql.Connection;

public class Test {
    Connection c;
    public Test() {
        c = pool.getConnection();
    }
}
        ]]></code>
    </test-code>
    <test-code reinitializeRule="true">
        <description>#1029 No instance level check in the close resource rule</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
import java.sql.Connection;

public class Test {
    Connection c;
    public void doIt() {
        c = pool.getConnection();
    }
}
        ]]></code>
    </test-code>
    <test-code>
        <description>#947 CloseResource rule fails if field is marked with annotation</description>
        <expected-problems>2</expected-problems>
        <code><![CDATA[
import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.Statement;

public class CloseResourceRuleBug {
  public void foo() {
    try {
      Connection c = DriverManager.getConnection("fake");
      Statement s = c.createStatement();
      @SuppressWarnings("PMD.CloseResource") ResultSet rs = s.executeQuery("fake");
      while (rs.next()) {
      }
      rs.close();
    } catch (SQLException e) {
    }
  }
}
]]></code>
    </test-code>

    <test-code>
        <description>#992 Class java.beans.Statement triggered in CloseResource rule</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
import java.beans.Statement;

public class Test {
    public void foo() {
        Statement stmt = new Statement(vo, "set" + prop, new Object[] { vector });

        try {
            stmt.execute();
        } catch (Exception e) {
            throw new RuntimeException("Could not set property prop: " + prop + "of type:" + pd.getPropertyType(), e);
        }
    }
}
        ]]></code>
    </test-code>

    <test-code>
        <description>Custom close method, should be ok</description>
        <rule-property name="closeTargets">cleanup</rule-property>
        <rule-property name="types">MyClass</rule-property>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
public class Foo {
   void bar() {
       MyClass myClass = null;
       try {
           myClass = new MyClass();
       } catch (Exception e) {
       } finally {
            myClass.cleanup(); // should be ok, it's closed with cleanup
       }
    }
 }
  ]]></code>
    </test-code>
    <test-code>
        <description>bug #1131 CloseResource should complain if code between declaration of resource and try: Code between declaration and try, should fail</description>
        <rule-property name="types">java.sql.Connection</rule-property>
        <expected-problems>1</expected-problems>
        <code><![CDATA[
import java.sql.Connection;

public class Foo {
    void bar() {
        String test = "";
        Connection c = pool.getConnection();
        if (test != null) {
            throw new RuntimeException("haha"); // <- RuntimeException, Connection  c is not closed
        }
        try {
        } catch (Exception e) {
        } finally {
           c.close();
        }
    }
}
        ]]></code>
    </test-code>
    <test-code>
        <description>bug #1131 CloseResource should complain if code between declaration of resource and try: Creation inside try, ok</description>
        <rule-property name="types">java.sql.Connection</rule-property>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
import java.sql.Connection;

public class Foo {
 void bar() {
  String test = "";
  Connection c = null;
  if (test != null) {
     throw new RuntimeException("haha");
  }
  try {
      // Creation inside try, ok
       c = pool.getConnection();
  } catch (Exception e) {
  } finally {
      if (c!= null) {
        c.close();
      }
  }
 }
}
        ]]></code>
    </test-code>
    <test-code>
        <description>bug #1131 CloseResource should complain if code between declaration of resource and try: No sentences between creation and try, ok</description>
        <rule-property name="types">java.sql.Connection</rule-property>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
import java.sql.Connection;

public class Foo {
 void bar() {
  String test = "";
  if (test != null) {
     throw new RuntimeException("haha");
  } 
  Connection c = pool.getConnection();
  // No sentences between creation and try, ok
  try {
  } catch (Exception e) {
  } finally {
      if (c!= null) {
        c.close();
      }
  }
 }
}
        ]]></code>
    </test-code>
    <test-code>
        <description>#1259 CloseResource rule ignores conditionals within finally blocks</description>
        <expected-problems>1</expected-problems>
        <code><![CDATA[
import java.sql.Connection;

public class Bar {
    public void foo() {
        Connection c = pool.getConnection();
        try {
            // do stuff
        } catch (SQLException ex) {
            // handle exception
        } finally {
            if(false) {
                c.close();
            }
        }
    }
}
        ]]></code>
    </test-code>
    <test-code>
        <description>#1375 CloseResource not detected properly - ok</description>
        <expected-problems>1</expected-problems>
        <code><![CDATA[
import java.sql.ResultSet;
import java.sql.Statement;

public class Foo {
 void bar() {
  ResultSet rs;
  Statement stmt = getConnection().createStatement();
  try {
  rs = stmt.getResultSet();
  rs.getString(0);
  rs.close();
  } catch (Exception e) {
    } finally {
   stmt.close();
  } 
 }
}
        ]]></code>
    </test-code>
    <test-code>
        <description>#1375 CloseResource not detected properly - false negative</description>
        <expected-problems>1</expected-problems>
        <code><![CDATA[
import java.sql.ResultSet;
import java.sql.Statement;

public class Foo {
 void bar() {
  ResultSet rs = null;
  Statement stmt = getConnection().createStatement();
  try {
  rs = stmt.getResultSet();
  rs.getString(0);
  rs.close();
  } catch (Exception e) {
    } finally {
   stmt.close();
  } 
 }
}
        ]]></code>
    </test-code>
    <test-code>
        <description>#1372 False Negative for CloseResource rule.</description>
        <rule-property name="types">java.sql.Connection,java.sql.Statement,java.sql.ResultSet,java.sql.PreparedStatement</rule-property>
        <rule-property name="closeTargets">closeLocalResources,closeResultSet</rule-property>
        <expected-problems>1</expected-problems>
        <expected-linenumbers>13</expected-linenumbers>
        <code><![CDATA[
import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.Statement;
import java.sql.PreparedStatement;

public class CloseResourceTest {
    public Object selectOne(final int val, final int val2) {
        getCurrentSession().doWork(new Work() {

        @Override
        public void execute(Connection connection) throws SQLException {
            PreparedStatement stmt = null;
            ResultSet rs = null;
            try {
                stmt = createDefaultPreparedStatement(connection, CONSTANTS.QUERY_STRING);
                stmt.setInt(1, vaL);
                stmt.setInt(2, val2);
                rs = stmt.executeQuery();
                // do result set processing
            } catch (SQLException se) {
                // error
            } finally {
                closeLocalResources(stmt);
                //closeResultSet(rs); // --- ERROR
            }
        }
        });
    }
}
        ]]></code>
    </test-code>

    <test-code>
        <description>#1387 CloseResource has false positive for ResultSet</description>
        <rule-property name="closeTargets">closeConnection,closeCloseable,closeReader,closeResource,closeResultSet,closeStream,closeStatement</rule-property>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
import java.sql.Connection;
import java.sql.ResultSet;
import java.sql.Statement;

public class CloseResource {
    public void querySomething(Connection connection) {
        Statement stmt = null; // it complains this is not closed
        ResultSet resultSet = null; // it complains this is not closed
        String someSql = "select something...";
        try {
            stmt = connection.createStatement();
            resultSet = stmt.executQuery(someSql);
            while (resultSet.next()) {
                // do something
            }
        } finally {
            if (resultSet != null) {
                resultSet.close();
            }
            if (stmt != null) {
                stmt.close();
            }
        }
    }
}
        ]]></code>
    </test-code>

    <test-code>
        <description>Verify closeAsDefaultTarget property</description>
        <rule-property name="closeAsDefaultTarget">false</rule-property>
        <expected-problems>2</expected-problems>
        <code><![CDATA[
import java.sql.ResultSet;
import java.sql.Statement;

public class CloseResource {
    public void doSomething() {
        Statement stmt = connection.createStatement();
        ResultSet resultSet = stmt.executeQuery("select ...");
        try {
        } finally {
            resultSet.close();
            stmt.close();
        }
    }
}
        ]]></code>
    </test-code>

    <test-code>
        <description>#1479 CloseResource false positive on Statement</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
public class Test {

    public static void main(String[] args) {
        Statement statement = new Statement();
    }

    static class Statement {
    }
}
        ]]></code>
    </test-code>

    <test-code>
        <description>CloseResource for input streams - not ok</description>
        <rule-property name="types">java.io.InputStream</rule-property>
        <expected-problems>1</expected-problems>
        <code><![CDATA[
import java.io.*;

public class CloseResourceTest {
    public static void main(String[] args) {
        InputStream in = null;
        try {
            in = new FileInputStream(new File("/tmp/foo"));
            in.read();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
        ]]></code>
    </test-code>

    <test-code>
        <description>CloseResource for file input streams - not ok</description>
        <rule-property name="types">java.io.InputStream</rule-property>
        <expected-problems>1</expected-problems>
        <code><![CDATA[
import java.io.*;

public class CloseResourceTest {
    public static void main(String[] args) {
        FileInputStream in = null;
        try {
            in = new FileInputStream(new File("/tmp/foo"));
            in.read();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
        ]]></code>
    </test-code>

    <test-code>
        <description>CloseResource for input streams - ok</description>
        <rule-property name="types">java.io.InputStream</rule-property>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
import java.io.*;

public class CloseResourceTest {
    public static void main(String[] args) {
        InputStream in = null;
        try {
            in = new FileInputStream(new File("/tmp/foo"));
            in.read();
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            in.close();
        }
    }
}
        ]]></code>
    </test-code>

    <test-code>
        <description>CloseResource for input streams - ok try-with-resources</description>
        <rule-property name="types">java.io.InputStream</rule-property>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
import java.io.*;

public class CloseResourceTest {
    public static void main(String[] args) {
        try (InputStream in = new FileInputStream(new File("/tmp/foo"))) {
            in.read();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
        ]]></code>
    </test-code>

    <test-code>
        <description>CloseResource for closable - not ok</description>
        <rule-property name="types">java.io.Closeable</rule-property>
        <expected-problems>2</expected-problems>
        <code><![CDATA[
import java.io.*;

public class CloseResourceTest {
    public static void main(String[] args) {
        InputStream in = null;
        OutputStream in2 = null;
        try {
            in = new FileInputStream(new File("/tmp/foo"));
            in.read();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
        ]]></code>
    </test-code>

    <test-code>
        <description>CloseResource for closable by default - not ok</description>
        <expected-problems>3</expected-problems>
        <expected-linenumbers>5,6,16</expected-linenumbers>
        <code><![CDATA[
import java.io.*;

public class CloseResourceTest {
    public static void main(String[] args) {
        InputStream in = null;
        OutputStream in2 = null;
        try {
            in = new FileInputStream(new File("/tmp/foo"));
            in.read();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    public void bar() {
        InputStream file = new FileInputStream(new File("/tmp/foo"));
        try {
            int c = file.in();
        } catch (IOException e) {
            // handle exception
        } finally {
            // TODO: close file
        }
    }
}
        ]]></code>
    </test-code>

    <test-code>
        <description>ByteArrayOutputStream and StringWriter do not need closing</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.StringWriter;
import java.io.OutputStream;

public class CloseResourceWithExceptions {
    public void bar() {
        /*ByteArray*/OutputStream buffer = new ByteArrayOutputStream();
        try {
            buffer.write(new byte[] {1, 2, 3});
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
        byte[] result = buffer.toByteArray();
        return result;
    }

    public String baz() {
        StringWriter writer = new StringWriter();
        writer.write("Test");
        return writer.toString();
    }
}
        ]]></code>
    </test-code>

    <test-code>
        <description>ByteArrayInputStream does not need closing</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;

public class CloseResourceWithExceptions {

    {
        ByteArrayInputStream bis = new ByteArrayInputStream("fooString".getBytes(StandardCharsets.UTF_8));
    }

    public int bar() {
        /*ByteArray*/InputStream buffer = new ByteArrayInputStream();
        try {
            return buffer.read();
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
        return -1;
    }
}
        ]]></code>
    </test-code>

    <test-code>
        <description>CharArrayWriter does not need closing</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
import java.io.Writer;
import java.io.CharArrayWriter;
import java.io.IOException;

public class CloseResourceWithExceptions {

    public char[] bar() {
        /*CharArray*/Writer buffer = new CharArrayWriter();
        try {
            buffer.append("foo");
            return buffer.toCharArray();
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
        return null;
    }
}
        ]]></code>
    </test-code>

    <test-code>
        <description>A custom StringWriter does need closing</description>
        <expected-problems>1</expected-problems>
        <code><![CDATA[
import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.StringWriter;
import net.sourceforge.pmd.lang.java.rule.errorprone.closeresource.CustomStringWriter;

public class CloseResourceWithExceptions {
    public void bar() {
        ByteArrayOutputStream buffer = new ByteArrayOutputStream();
        try {
            buffer.write(new byte[] {1, 2, 3});
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
        byte[] result = buffer.toByteArray();
        return result;
    }

    public String baz() {
        StringWriter writer = new CustomStringWriter();
        writer.write("Test");
        return writer.toString();
    }
}
        ]]></code>
    </test-code>

    <test-code>
        <description>connection not closed, should have failed - missing import</description>
        <expected-problems>1</expected-problems>
        <code><![CDATA[
// without the import
//import java.sql.*;
// type resolution doesn't work, so the rule falls back to simple names
public class Foo {
 void bar() {
  Connection c = pool.getConnection();
  try {
  } catch (Exception e) {
  }
 }
}
     ]]></code>
    </test-code>

    <test-code>
        <description>closed with try-with-resources</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
import java.io.*;

public class Foo {
    public int bar() {
        InputStream inputStream = getInputStreamFromSomewhere();
        if (inputStream != null) {
            try (InputStreamReader reader = new InputStreamReader(inputStream, "UTF-8")) {
                char c = reader.read();
                return c;
            }
        }
        return -1;
    }
}
        ]]></code>
    </test-code>

    <test-code>
        <description>Correctly determine the type with method calls</description>
        <expected-problems>2</expected-problems>
        <expected-linenumbers>6,7</expected-linenumbers>
        <expected-messages>
            <message>Ensure that resources like this Connection object are closed after use</message>
            <message>Ensure that resources like this PreparedStatement object are closed after use</message>
        </expected-messages>
        <code><![CDATA[
import java.sql.*;

public class CloseResourceSQL {
    public void run() {
        try {
            Connection con = DataSourceUtils.getConnection(ds);
            PreparedStatement ps = con.prepareStatement("some SQL statement");
            DataSourceUtils.applyTransactionTimeout(ps, ds);
        } catch (SQLException ex) {
            throw new RuntimeException("", ex);
        }
    }
}
        ]]></code>
    </test-code>

    <test-code>
        <description>JMS Connections without auxclasspath</description>
        <expected-problems>1</expected-problems>
        <expected-linenumbers>10</expected-linenumbers>
        <expected-messages>
            <message>Ensure that resources like this Connection object are closed after use</message>
        </expected-messages>
        <code><![CDATA[
// javax.jms.* is not on the (aux)classpath during unit tests
import javax.jms.Connection;
import javax.jms.Session;

public class CloseResourceJMS {
    public void run() {
        Session session = resourceFactory.getSession(resourceHolder);
        if (session != null) {
            if (startConnection) {
                Connection con = resourceFactory.getConnection(resourceHolder);
                if (con != null) {
                    con.start();
                }
            }
            return session;
        }
        return null;
    }
}
        ]]></code>
    </test-code>

    <test-code>
        <description>CloseResource for closable - ignored if the types do not contain AutoClosable</description>
        <rule-property name="types">java.sql.Connection,java.sql.Statement,java.sql.ResultSet</rule-property>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
import java.io.*;

public class CloseResourceTest {
    public static void main(String[] args) {
        InputStream in = null;
        OutputStream in2 = null;
        try {
            in = new FileInputStream(new File("/tmp/foo"));
            in.read();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

    public void bar() {
        InputStream file = new FileInputStream(new File("/tmp/foo"));
        try {
            int c = file.in();
        } catch (IOException e) {
            // handle exception
        } finally {
            // TODO: close file
        }
    }
}
        ]]></code>
    </test-code>

    <test-code>
        <description>PrintWriter based on StringWriter</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
import java.io.*;

public class CloseResourcePrintWriter {
    public String run1() {
        StringWriter sw = new StringWriter();
        PrintWriter pw = new PrintWriter(sw);

        pw.println("Foo");
        String result = sw.toString();
        return result;
    }

    public String run2() {
        StringWriter sw = new StringWriter();
        PrintWriter pw = new PrintWriter(sw, true);

        pw.println("Foo");
        String result = sw.toString();
        return result;
    }

    public String run3() {
        StringWriter sw = new StringWriter();
        PrintWriter pw = new PrintWriter(new BufferedWriter(sw));

        pw.println("Foo");
        return sw.toString();
    }
}
        ]]></code>
    </test-code>

    <test-code>
        <description>Correctly determine the type for the message</description>
        <expected-problems>3</expected-problems>
        <expected-linenumbers>7,8,10</expected-linenumbers>
        <expected-messages>
            <message>Ensure that resources like this FileInputStream object are closed after use</message>
            <message>Ensure that resources like this Scanner object are closed after use</message>
            <message>Ensure that resources like this FileInputStream object are closed after use</message>
        </expected-messages>
        <code><![CDATA[
import java.io.*;
import java.util.Scanner;

public class CloseResourceCase {
    public void run() {
        try {
            FileInputStream in = new FileInputStream("MyFile.txt");
            Scanner input = new Scanner(System.in, "utf-8");
            String file = "MyFile.txt";
            FileInputStream in2 = new FileInputStream(file);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
        ]]></code>
    </test-code>

    <test-code>
        <description>#1966 [java] CloseResource false positive if Stream is passed as method parameter</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
import java.io.*;

public class CloseResourceFP {
    public void check(InputStream in) {
        if (in instanceof FileInputStream) {
            FileInputStream fin = (FileInputStream) in;
            doCheck(fin);
        } else if (in instanceof ByteArrayInputStream) {
            ByteArrayInputStream bin = (ByteArrayInputSream) in;
            doCheck(bin);
        } else {
            BufferedInputStream buf = new BufferedInputStream(in);
            doCheck(buf);
        }
    }

    public void dump(final Writer writer) {
        final PrintWriter printWriter = writer instanceof PrintWriter ? (PrintWriter) writer : new PrintWriter(writer);
        printWriter.println(this);
    }
}
        ]]></code>
    </test-code>

    <test-code>
        <description>#1967 [java] CloseResource false positive with late assignment of variable</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
import java.io.*;

public class CloseResourceFP {
    public void check(File outputFile) {
        final OutputStream os;
        if (outputFile == null) {
            os = System.out;
        } else if (outputFile.isAbsolute()) {
            os = Files.newOutputStream(outputFile.toPath());
        } else {
            os = Files.newOutputStream(new File(getProject().getBaseDir(), outputFile.toString()).toPath());
        }

        try (Writer writer = new BufferedWriter(new OutputStreamWriter(os, "UTF-8"))) {
            renderer.render(cpd.getMatches(), writer);
        }
    }
}
        ]]></code>
    </test-code>

    <test-code>
        <description>#1922 [java] CloseResource possible false positive with Streams</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
import java.util.*;
import java.util.function.*;
import java.util.regex.*;
import java.util.stream.*;

public class CloseResourceStream {
     public static <T> Stream<MatchResult<T>> filterResults(List<T> candidates, Function<T, String> matchExtractor, String query, MatchSelector<T> limiter) {
        if (query.length() < MIN_QUERY_LENGTH) {
            return Stream.empty();
        }

        // violation here
        Stream<MatchResult<T>> base = candidates.stream()
                                                .map(it -> {
                                                    String cand = matchExtractor.apply(it);
                                                    return new MatchResult<>(0, it, cand, query, new TextFlow(makeNormalText(cand)));
                                                });
        return limiter.selectBest(base);
    }
}
        ]]></code>
    </test-code>

    <test-code>
        <description>#2402 [java] CloseResource possible false positive with primitive  Streams</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[

import java.util.stream.*;

public class CloseResourceStreamInt {
     public void reproduceIntStream() {
        IntStream iStream = IntStream.of(1).filter(i -> i < 5);
        iStream.anyMatch(i -> i < 5);
    }

    public void reproduceIntStream() {
        LongStream lStream = LongStream.of(1).filter(i -> i < 5);
        lStream.anyMatch(i -> i < 5);
    }

    public void reproduceIntStream() {
        DoubleStream dStream = DoubleStream.of(1).filter(i -> i < 5);
        dStream.anyMatch(i -> i < 5);
    }
}
        ]]></code>
    </test-code>




    <test-code>
        <description>#1076 [java] CloseResource false positive on non-SQL classes called Statement</description>
        <expected-problems>0</expected-problems>
        <code><![CDATA[
import net.sourceforge.pmd.lang.java.rule.errorprone.closeresource.Statement;

public class CloseResourceStatementFP {
    public void check() {
        Statement s = new Statement();
    }
}
        ]]></code>
    </test-code>

    <test-code>
        <description>False-negative if only byte array is passed in as method parameter</description>
        <expected-problems>1</expected-problems>
        <expected-linenumbers>6</expected-linenumbers>
        <code><![CDATA[
import java.io.*;

public class CloseResourceFN {
    public Object deserialize(byte[] bytes) {
        try {
            ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(bytes));
            return ois.readObject();
        }
        catch (IOException ex) {
            throw new IllegalArgumentException("Failed to deserialize object", ex);
        }
        catch (ClassNotFoundException ex) {
            throw new IllegalStateException("Failed to deserialize object type", ex);
        }
    }
}
        ]]></code>
    </test-code>

    <test-code>
        <description>NullPointerException if type of method parameter is not known</description>
        <expected-problems>1</expected-problems>
        <code><![CDATA[
import java.io.*;
public class CloseResourceNullPointer {
    public void check(UnknownType param) {
        InputStream in = param;
    }
}
        ]]></code>
    </test-code>
</test-data>
