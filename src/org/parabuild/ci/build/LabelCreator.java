/*
 * Parabuild CI licenses this file to You under the LGPL 2.1
 * (the "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *      https://www.gnu.org/licenses/lgpl-3.0.txt
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.parabuild.ci.build;

import org.apache.commons.logging.Log;
import org.apache.commons.logging.LogFactory;

import org.parabuild.ci.util.BuildException;
import org.parabuild.ci.util.CommandStoppedException;
import org.parabuild.ci.util.StringUtils;
import org.parabuild.ci.configuration.ConfigurationManager;
import org.parabuild.ci.object.BuildConfig;
import org.parabuild.ci.object.BuildRun;
import org.parabuild.ci.object.LabelProperty;
import org.parabuild.ci.versioncontrol.SourceControl;

/**
 * Responsible for labeling build runs.
 */
final class LabelCreator {

  /**
   * @noinspection UNUSED_SYMBOL,UnusedDeclaration
   */
  private static final Log log = LogFactory.getLog(BuildRunner.class); // NOPMD

  private final SourceControl sourceControl;
  private final String manualLabel;


  /**
   * Creates label creator.
   *
   * @param manualLabel is a label that will be added in addition
   *                    to labels generated by build configuration, such as label
   *                    called from manual build starts.
   */
  LabelCreator(final SourceControl sourceControl, final String manualLabel) {
    this.sourceControl = sourceControl;
    this.manualLabel = manualLabel;
  }


  /**
   * Labels build run.
   *
   * @param buildRun        to label
   * @param runConfig       current build config
   * @param manualLabelOnly
   */
  public void labelBuildRun(final BuildRun buildRun, final BuildConfig runConfig, final boolean manualLabelOnly)
          throws BuildException, CommandStoppedException, AgentFailureException {

    if (log.isDebugEnabled()) log.debug("buildRun: " + buildRun);
    if (log.isDebugEnabled()) log.debug("manualLabelOnly: " + manualLabelOnly);
    final ConfigurationManager cm = ConfigurationManager.getInstance();
    if (buildRun.getResultID() == BuildRun.BUILD_RESULT_SUCCESS) {

      if (!manualLabelOnly) {
        // label if labeling was defined in the build configuration
        final LabelProperty lp = cm.getLabelSetting(runConfig.getBuildID(), LabelProperty.LABEL_TYPE);
        if (lp != null && lp.getPropertyValue().equals(LabelProperty.LABEL_TYPE_CUSTOM)) {
          final LabelProperty ltp = cm.getLabelSetting(runConfig.getBuildID(), LabelProperty.LABEL_CUSTOM_VALUE);
          final BuildLabelNameGenerator nameGenerator = new BuildLabelNameGenerator();
          nameGenerator.setLabelTemplate(ltp.getPropertyValue());
          nameGenerator.setBuildName(buildRun.getBuildName());
          nameGenerator.setBuildNumber(buildRun.getBuildRunNumber());
          nameGenerator.setBuildTimestamp(buildRun.getStartedAt());
          nameGenerator.setChangeListNumber(buildRun.getChangeListNumber());
          final String buildLabel = nameGenerator.generateLabelName();
          // request SC to place label
          sourceControl.label(buildLabel);
          buildRun.setLabel(buildLabel);
          buildRun.setLabelStatus(BuildRun.LABEL_SET);
        }
      }

      // label if add-on label was defined
      if (!StringUtils.isBlank(manualLabel)) {
        // request SC to place add-on label
        sourceControl.label(manualLabel);
        buildRun.setManualLabel(manualLabel);
        buildRun.setLabelStatus(BuildRun.LABEL_SET);
      }
    }
  }


  public String toString() {
    return "LabelCreator{" +
            "sourceControl=" + sourceControl +
            ", manualLabel='" + manualLabel + '\'' +
            '}';
  }
}
